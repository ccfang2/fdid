fixed_line_width   <- strwidth("Classical", cex=scale.legend)
extra_padding      <- strwidth("   ", cex=scale.legend) # add extra padding for the white rectangle to avoid text touching borders
rect_width         <- max(text_width_upper, text_width_lower)+extra_padding+fixed_rect_b_width  # calculate the width of the white rectangle (A) based on the longest text
rect_height        <- diff(ylim)*0.1*scale.legend # define the height for the white rectangle (A)
rect_x1            <- mean(xlim)-rect_width/2 # define positions for the white rectangle A (centered)
rect_x2            <- mean(xlim)+rect_width/2
if(pos.legend=="top")    {rect_y2 <- ylim[2]-rect_height*0.5; rect_y1 <- rect_y2-rect_height}
if(pos.legend=="bottom") {rect_y2 <- ylim[1]+rect_height*0.5; rect_y1 <- rect_y2+rect_height}
rect(rect_x1, rect_y1, rect_x2, rect_y2, col = "white", border = "black") # draw white rectangular A with black border
left_padding <- rect_width*0.05 # define padding to prevent touching the left border
rect_b_x1    <- rect_x1+left_padding  # position and draw the fixed-width red rectangle B (aligned with upper text)
rect_b_x2    <- rect_b_x1+fixed_rect_b_width
if(pos.legend=="top")    {rect_b_y2 <- rect_y2-rect_height*0.15; rect_b_y1 <- rect_b_y2-rect_height*0.35}
if(pos.legend=="bottom") {rect_b_y2 <- rect_y1-rect_height*0.5; rect_b_y1 <- rect_b_y2+rect_height*0.35}
# if (isTRUE(ref.band.pre)) {
#   rect_b_xmid <- (rect_b_x1 + rect_b_x2) / 2   # compute the middle x coordinate
#   rect(rect_b_x1, rect_b_y1, rect_b_xmid, rect_b_y2, col = rgb(1, 0, 0, alpha = 0.2),  border = NA) # draw the left half (more transparent red)
#   rect(rect_b_xmid, rect_b_y1, rect_b_x2, rect_b_y2, col = rgb(1, 0, 0, alpha = 0.4), border = NA)  # draw the right half (less transparent red)
# } else{
#   rect(rect_b_x1, rect_b_y1, rect_b_x2, rect_b_y2, col = rgb(1, 0, 0, alpha = 0.4), border = NA)  # draw red rectangle B (transparent, no border)
# }
# text(rect_b_x2 + left_padding, (rect_b_y1 + rect_b_y2) / 2, upper_text, cex = scale.legend,  adj = 0)  # add upper text next to red rectangle B
rect_b_xmid <- (rect_b_x1 + rect_b_x2) / 2
rect_b_ymid <- (rect_b_y1 + rect_b_y2) / 2
points(rect_b_xmid, rect_b_ymid, pch = 21, bg = "blue", cex = scale.legend)
text(rect_b_x2 + left_padding, (rect_b_y1 + rect_b_y2) / 2, upper_text, cex = scale.legend,  adj = 0)  # add upper text next to red rectangle B
if(pos.legend=="top")    {line_y <- rect_y1+rect_height*0.3}
if(pos.legend=="bottom") {line_y <- rect_y2+rect_height*0.3}
segments(line_x1, line_y, line_x2, line_y, col = "red", lwd = 4*scale.legend, lty = 3)  # draw the red dashed line (fixed width)
##
xlim <- par("usr")[1:2]
ylim <- par("usr")[3:4]
upper_text <- "Event Study (DiD) Estimates"; lower_text <- "Classical Reference Line            "
text_width_upper   <- strwidth(upper_text, cex=scale.legend) # calculate the width of the text dynamically
text_width_lower   <- strwidth(lower_text, cex=scale.legend)
fixed_rect_b_width <- strwidth("Classical", cex=scale.legend) # define a longer fixed width for the red rectangle (B) and red dashed line
fixed_line_width   <- strwidth("Classical", cex=scale.legend)
extra_padding      <- strwidth("   ", cex=scale.legend) # add extra padding for the white rectangle to avoid text touching borders
rect_width         <- max(text_width_upper, text_width_lower)+extra_padding+fixed_rect_b_width  # calculate the width of the white rectangle (A) based on the longest text
rect_height        <- diff(ylim)*0.1*scale.legend # define the height for the white rectangle (A)
rect_x1            <- mean(xlim)-rect_width/2 # define positions for the white rectangle A (centered)
rect_x2            <- mean(xlim)+rect_width/2
if(pos.legend=="top")    {rect_y2 <- ylim[2]-rect_height*0.5; rect_y1 <- rect_y2-rect_height}
if(pos.legend=="bottom") {rect_y2 <- ylim[1]+rect_height*0.5; rect_y1 <- rect_y2+rect_height}
rect(rect_x1, rect_y1, rect_x2, rect_y2, col = "white", border = "black") # draw white rectangular A with black border
left_padding <- rect_width*0.05 # define padding to prevent touching the left border
rect_b_x1    <- rect_x1+left_padding  # position and draw the fixed-width red rectangle B (aligned with upper text)
rect_b_x2    <- rect_b_x1+fixed_rect_b_width
if(pos.legend=="top")    {rect_b_y2 <- rect_y2-rect_height*0.15; rect_b_y1 <- rect_b_y2-rect_height*0.35}
if(pos.legend=="bottom") {rect_b_y2 <- rect_y1-rect_height*0.5; rect_b_y1 <- rect_b_y2+rect_height*0.35}
# if (isTRUE(ref.band.pre)) {
#   rect_b_xmid <- (rect_b_x1 + rect_b_x2) / 2   # compute the middle x coordinate
#   rect(rect_b_x1, rect_b_y1, rect_b_xmid, rect_b_y2, col = rgb(1, 0, 0, alpha = 0.2),  border = NA) # draw the left half (more transparent red)
#   rect(rect_b_xmid, rect_b_y1, rect_b_x2, rect_b_y2, col = rgb(1, 0, 0, alpha = 0.4), border = NA)  # draw the right half (less transparent red)
# } else{
#   rect(rect_b_x1, rect_b_y1, rect_b_x2, rect_b_y2, col = rgb(1, 0, 0, alpha = 0.4), border = NA)  # draw red rectangle B (transparent, no border)
# }
# text(rect_b_x2 + left_padding, (rect_b_y1 + rect_b_y2) / 2, upper_text, cex = scale.legend,  adj = 0)  # add upper text next to red rectangle B
rect_b_xmid <- (rect_b_x1 + rect_b_x2) / 2
rect_b_ymid <- (rect_b_y1 + rect_b_y2) / 2
points(rect_b_xmid, rect_b_ymid, pch = 21, bg = "blue", cex = scale.legend)
text(rect_b_x2 + left_padding, (rect_b_y1 + rect_b_y2) / 2, upper_text, cex = scale.legend,  adj = 0)  # add upper text next to red rectangle B
line_x1 <- rect_b_x1  # define position for the red dashed line (aligned with lower text) # same as red rectangle start
line_x2 <- rect_b_x2  # same fixed width as red rectangle
#line_y <- rect_y1+rect_height*0.3
if(pos.legend=="top")    {line_y <- rect_y1+rect_height*0.3}
if(pos.legend=="bottom") {line_y <- rect_y2+rect_height*0.3}
segments(line_x1, line_y, line_x2, line_y, col = "red", lwd = 4*scale.legend, lty = 3)  # draw the red dashed line (fixed width)
text(line_x2 + left_padding, line_y, lower_text, cex = scale.legend, adj = 0)  # add lower text next to the red dashed line
#####
library(devtools)
document()
install()
library(fdid)
cov_mat <- cov(matrix(rnorm(250),nrow=50))
grid <- seq(0,1,len=5)
cov_spline_mat <- cov_spline(cov=cov_mat, grid=grid, n_intrpl=50)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
par(cex.axis = 1.4, cex.lab = 1.4, cex.main = 1.4)
EventStudyPlot_Classical(fdid_scb_est, scale.legend=1.4)
## adding a label for Y-axis
title(ylab="Effects of Duty-to-Bargain Laws")
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
par(cex.axis = 1.4, cex.lab = 1.4, cex.main = 1.4)
EventStudyPlot_Classical(fdid_scb_est, scale.legend=1.4)
## adding a label for Y-axis
title(ylab="Effects of Duty-to-Bargain Laws")
data(LWdata)
fdid_scb_est1 <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
data(simulated_stagger_example)
fdid_est2 <- fdid(data=simulated_stagger_data, treatment=simulated_stagger_treatment)
fdid_scb_est2 <- fdid_scb(object=fdid_est2)
plot(fdid_scb_est2)
data(simulated_stagger_example)
fdid_est <- fdid(data=simulated_stagger_data, treatment=simulated_stagger_treatment)
plot(fdid_est$beta$coef[,2], fdid_est$beta$coef[,1], type="l",
xlab="Event Time", ylab=expression(hat(beta)), family="Times")
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
cat("The reference time is ", LWdata$t0, ". If not NULL, the input 'ta.ts' in function 'plot' should be smaller than this value.", sep="")
## simultaneous inference
par(cex.axis = 1.4, cex.lab = 1.4, cex.main = 1.4)
plot(fdid_scb_est, scale.legend=1.4)
## adding a label for Y-axis
title(ylab="Effects of Duty-to-Bargain Laws")
## honest inference under treatment anticipation
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4)
## honest inference under violation of parallel trends assumption
plot(fdid_scb_est, frmtr.m=c(0.4,0.4), scale.legend=1.4)
set.seed(100)
x <- rnorm(20)
t <- rep(1:5, each = 4)
i <- rep(letters[1:4], times=5)
df_transf <- tw_transf(x,t,i)
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
cat("The reference time is ", LWdata$t0, ". If not NULL, the input 'ta.ts' in function 'plot' should be smaller than this value.", sep="")
## simultaneous inference
par(cex.axis = 1.4, cex.lab = 1.4, cex.main = 1.4)
plot(fdid_scb_est, scale.legend=1.4)
## adding a label for Y-axis
title(ylab="Effects of Duty-to-Bargain Laws")
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, ta.s=(-1.5,4), scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, ta.s=c(-1.5,4), scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, ta.s=c(1.5,4), scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, ta.s=c(4,2), scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, ta.s=c(10,2), scale.legend=1.4)
library(devtools)
document()
install()
library(fdid)
data(Gdata)
fdid_scb_est <- fdid_scb(beta=Gdata$beta, cov=Gdata$cov, t0=Gdata$t0)
object <- fdid_scb_est
ta.ts=NULL
ta.s=NULL
frmtr.m=c(0.28,2.8)
ref.band.pre=TRUE
note.pre=TRUE
note.post=TRUE
ci.pre=FALSE
ci.post=FALSE
pos.legend="top"
scale.legend=1
# check conditions
if (!base::inherits(object,"fdid_scb")) stop("The input 'object' should be an output of function 'fdid_scb'.")
if (!is.null(ta.ts) && (!is.numeric(ta.ts) || length(ta.ts) != 1)) stop("The input 'ta.ts' should be either NULL or a numeric scalar.")
if (!is.null(ta.ts) && !(ta.ts %in% object$scb$event_t[which(object$scb$event_t<=object$data$t0)])) stop("If not NULL, the input 'ta.ts' should be among the pre-treatment event time in 'object'.")
if (!is.null(ta.ts) && ta.ts == object$scb$event_t[1] && !all(sapply(list( frmtr.m), is.null))) stop("If 'ta.ts' is defined to be the first event time, 'frmtr.m' must be NULL, because there is no available data for computing pre-trend differences.")
if (!is.null(ta.s) && (!is.numeric(ta.s) || length(ta.s) != 2 || any(ta.s <0) )) stop("The input 'ta.s' should be either NULL or a numeric non-negative vector of length two.")
if (!is.null(frmtr.m) && (!is.numeric(frmtr.m) || length(frmtr.m) != 2 || any(frmtr.m<0) )) stop("The input 'frmtr.m' should be either NULL or a numeric non-negative vector of length two.")
if (!is.logical(ref.band.pre)) stop("The input 'ref.band.pre' should be logical.")
if (!is.logical(note.pre)) stop("The input 'note.pre' should be logical.")
if (!is.logical(note.post)) stop("The input 'note.post' should be logical.")
if (!is.logical(ci.pre)) stop("The input 'ci.pre' should be logical.")
if (!is.logical(ci.post)) stop("The input 'ci.post' should be logical.")
if (!is.null(pos.legend) && !pos.legend %in% c("top", "bottom")) stop("The input 'pos.legend' must be 'top', 'bottom', or NULL.")
if (!is.numeric(scale.legend) || length(scale.legend) != 1 || scale.legend <= 0 || !is.finite(scale.legend)) stop("The input 'scale.legend' must be a positive number.")
# extract data from object
betahat <- object$data$beta[,1]
covhat  <- object$data$cov
timeVec <- object$data$beta[,2]
betahat_splinefun <- object$scb$betahat
scb_ub_splinefun  <- object$scb$scb_ub
scb_lb_splinefun  <- object$scb$scb_lb
ci_upper <- object$ci[,"ci_upper"]
ci_lower <- object$ci[,"ci_lower"]
start                     <- min(object$data$beta[,2])
end                       <- max(object$data$beta[,2])
t0                        <- object$data$t0
ci.alpha                  <- object$data$ci.alpha
scb.pre.alpha             <- object$data$scb.pre.alpha
scb.post.alpha            <- object$data$scb.post.alpha
is.null(ta.ts)
if (is.null(ta.ts)) ta.ts <- t0
is.null(frmtr.m)
!is.null(frmtr.m)
ta.ts==t0 & is.null(frmtr.m)
is.null(ta.s)
if(is.null(ta.s)) {
ta_ub <- ci_upper[names(ci_upper)==as.character(ta.ts)]
ta_lb <- ci_lower[names(ci_lower)==as.character(ta.ts)]
} else {
ta.s1 <- ta.s[1]
ta.s2 <- ta.s[2]
ta_ub <- betahat[which(timeVec==ta.ts)]+ta.s1*sqrt(diag(covhat)[which(timeVec==ta.ts)])
ta_lb <- betahat[which(timeVec==ta.ts)]-ta.s2*sqrt(diag(covhat)[which(timeVec==ta.ts)])
}
ta_ub
ta_lb
ci_upper[names(ci_upper)==as.character(ta.ts)]
is.null(ta.s)
names(ci_upper)
as.character(ta.ts)
names(ci_upper)==as.character(ta.ts)
ci_upper
t0
if(is.null(ta.s)) {
ta_ub <- ci_upper[names(ci_upper)==as.character(ta.ts)]
ta_lb <- ci_lower[names(ci_lower)==as.character(ta.ts)]
} else {
ta.s1 <- ta.s[1]
ta.s2 <- ta.s[2]
ta_ub <- betahat[which(timeVec==ta.ts)]+ta.s1*sqrt(diag(covhat)[which(timeVec==ta.ts)])
ta_lb <- betahat[which(timeVec==ta.ts)]-ta.s2*sqrt(diag(covhat)[which(timeVec==ta.ts)])
}
ts             <- seq(start, ta.ts, length.out=50*sum(timeVec<=ta.ts))
betas_deriv    <- pracma::fderiv(betahat_splinefun, ts, n=1, method="backward")
mean_abs_deriv <- mean(abs(betas_deriv))
slope          <- mean(betas_deriv)
frmtr.m1 <- frmtr.m[1]
frmtr.m2 <- frmtr.m[2]
ftr_ub_ta_ub <- function (x) {ifelse(x>=ta.ts, (frmtr.m1*mean_abs_deriv+slope)*(x-ta.ts)+ta_ub, (-frmtr.m2*mean_abs_deriv+slope)*(x-ta.ts)+ta_ub)}
ftr_lb_ta_ub <- function (x) {ifelse(x>=ta.ts, (-frmtr.m2*mean_abs_deriv+slope)*(x-ta.ts)+ta_ub, (frmtr.m1*mean_abs_deriv+slope)*(x-ta.ts)+ta_ub)}
ftr_ub_ta_lb <- function (x) {ifelse(x>=ta.ts, (frmtr.m1*mean_abs_deriv+slope)*(x-ta.ts)+ta_lb, (-frmtr.m2*mean_abs_deriv+slope)*(x-ta.ts)+ta_lb)}
ftr_lb_ta_lb <- function (x) {ifelse(x>=ta.ts, (-frmtr.m2*mean_abs_deriv+slope)*(x-ta.ts)+ta_lb, (frmtr.m1*mean_abs_deriv+slope)*(x-ta.ts)+ta_lb)}
x_vals <- seq(start, end, length.out=5*length(timeVec))
if (ta.ts!=t0) {
honest_ub_vals <- apply(cbind(ta_ub, ftr_ub_ta_ub(x_vals), ftr_ub_ta_lb(x_vals)), 1,  function(row) max(row,na.rm=TRUE))
honest_lb_vals <- apply(cbind(ta_lb, ftr_lb_ta_ub(x_vals), ftr_lb_ta_lb(x_vals)), 1,  function(row) min(row,na.rm=TRUE))
} else {
honest_ub_vals <- apply(cbind(ftr_ub_ta_ub(x_vals), ftr_ub_ta_lb(x_vals)), 1,  function(row) if (all(is.na(row))) 0 else max(row,na.rm=TRUE))
honest_lb_vals <- apply(cbind(ftr_lb_ta_ub(x_vals), ftr_lb_ta_lb(x_vals)), 1,  function(row) if (all(is.na(row))) 0 else min(row,na.rm=TRUE))
}
honest_ub_splinefun <- splinefun(x=x_vals, y=honest_ub_vals, method="natural")
honest_lb_splinefun <- splinefun(x=x_vals, y=honest_lb_vals, method="natural")
honest_ub_splinefun <- Vectorize(honest_ub_splinefun)
honest_lb_splinefun <- Vectorize(honest_lb_splinefun)
}
if(is.null(ta.s)) {
ta_ub <- ci_upper[names(ci_upper)==as.character(ta.ts)]
ta_lb <- ci_lower[names(ci_lower)==as.character(ta.ts)]
} else {
ta.s1 <- ta.s[1]
ta.s2 <- ta.s[2]
ta_ub <- betahat[which(timeVec==ta.ts)]+ta.s1*sqrt(diag(covhat)[which(timeVec==ta.ts)])
ta_lb <- betahat[which(timeVec==ta.ts)]-ta.s2*sqrt(diag(covhat)[which(timeVec==ta.ts)])
}
# frmtr bounds
ts             <- seq(start, ta.ts, length.out=50*sum(timeVec<=ta.ts))
betas_deriv    <- pracma::fderiv(betahat_splinefun, ts, n=1, method="backward")
mean_abs_deriv <- mean(abs(betas_deriv))
slope          <- mean(betas_deriv)
frmtr.m1 <- frmtr.m[1]
frmtr.m2 <- frmtr.m[2]
ftr_ub_ta_ub <- function (x) {ifelse(x>=ta.ts, (frmtr.m1*mean_abs_deriv+slope)*(x-ta.ts)+ta_ub, (-frmtr.m2*mean_abs_deriv+slope)*(x-ta.ts)+ta_ub)}
ftr_lb_ta_ub <- function (x) {ifelse(x>=ta.ts, (-frmtr.m2*mean_abs_deriv+slope)*(x-ta.ts)+ta_ub, (frmtr.m1*mean_abs_deriv+slope)*(x-ta.ts)+ta_ub)}
ftr_ub_ta_lb <- function (x) {ifelse(x>=ta.ts, (frmtr.m1*mean_abs_deriv+slope)*(x-ta.ts)+ta_lb, (-frmtr.m2*mean_abs_deriv+slope)*(x-ta.ts)+ta_lb)}
ftr_lb_ta_lb <- function (x) {ifelse(x>=ta.ts, (-frmtr.m2*mean_abs_deriv+slope)*(x-ta.ts)+ta_lb, (frmtr.m1*mean_abs_deriv+slope)*(x-ta.ts)+ta_lb)}
x_vals <- seq(start, end, length.out=5*length(timeVec))
if (ta.ts!=t0) {
honest_ub_vals <- apply(cbind(ta_ub, ftr_ub_ta_ub(x_vals), ftr_ub_ta_lb(x_vals)), 1,  function(row) max(row,na.rm=TRUE))
honest_lb_vals <- apply(cbind(ta_lb, ftr_lb_ta_ub(x_vals), ftr_lb_ta_lb(x_vals)), 1,  function(row) min(row,na.rm=TRUE))
} else {
honest_ub_vals <- apply(cbind(ftr_ub_ta_ub(x_vals), ftr_ub_ta_lb(x_vals)), 1,  function(row) if (all(is.na(row))) 0 else max(row,na.rm=TRUE))
honest_lb_vals <- apply(cbind(ftr_lb_ta_ub(x_vals), ftr_lb_ta_lb(x_vals)), 1,  function(row) if (all(is.na(row))) 0 else min(row,na.rm=TRUE))
}
honest_ub_splinefun <- splinefun(x=x_vals, y=honest_ub_vals, method="natural")
honest_lb_splinefun <- splinefun(x=x_vals, y=honest_lb_vals, method="natural")
honest_ub_splinefun <- Vectorize(honest_ub_splinefun)
honest_lb_splinefun <- Vectorize(honest_lb_splinefun)
n.int <-200
roots_UB <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun         <- function(x) (scb_ub_splinefun(x)-honest_ub_splinefun(x))*(scb_lb_splinefun(x)-honest_ub_splinefun(x))
interval    <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root        <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots_UB[i] <- if(inherits(root, "try-error")) {NA} else root
}
roots_UB <- sort(unique(roots_UB[!is.na(roots_UB)]))
roots_LB <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun         <- function(x) (scb_ub_splinefun(x)-honest_lb_splinefun(x))*(scb_lb_splinefun(x)-honest_lb_splinefun(x))
interval    <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root        <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots_LB[i] <- if(inherits(root, "try-error")) {NA} else root
}
roots_LB <-  sort(unique(roots_LB[!is.na(roots_LB)]))
roots_UB_vec <- sort(unique(c(start,roots_UB,end)))
roots_LB_vec <- sort(unique(c(start,roots_LB,end)))
roots_vec    <- sort(unique(c(start,end,roots_UB, roots_LB)))
stat_sig_UB_vec <- rep(NA, length(roots_UB_vec)-1)
stat_sig_LB_vec <- rep(NA, length(roots_LB_vec)-1)
for (i in 1:(length(roots_UB_vec)-1)) {
test_point <- (roots_UB_vec[i]+roots_UB_vec[i+1])/2
scb_ub_sign <- sign(scb_ub_splinefun( test_point)-honest_ub_splinefun(test_point))
scb_lb_sign <- sign(scb_lb_splinefun( test_point)-honest_ub_splinefun(test_point))
stat_sig_UB_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
for (i in 1:(length(roots_LB_vec)-1)) {
test_point <- (roots_LB_vec[i]+roots_LB_vec[i+1])/2
scb_ub_sign <- sign(scb_ub_splinefun( test_point)-honest_lb_splinefun(test_point))
scb_lb_sign <- sign(scb_lb_splinefun( test_point)-honest_lb_splinefun(test_point))
stat_sig_LB_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
interval_fun <- function(x, a, b) {
if (length(b) != length(a) - 1) {
stop("Vector 'b' must be one element shorter than vector 'a'.")
}
for (i in 1:(length(a) - 1)) {
if (x >= a[i] && x <= a[i + 1]) {
return(b[i])
}
}
return(NA)
}
fun_stat_sig_UB_vec <- function(x) interval_fun(x, roots_UB_vec, stat_sig_UB_vec)
fun_stat_sig_LB_vec <- function(x) interval_fun(x, roots_LB_vec, stat_sig_LB_vec)
fun_stat_sig_UB_vec <- Vectorize(fun_stat_sig_UB_vec)
fun_stat_sig_LB_vec <- Vectorize(fun_stat_sig_LB_vec)
fun_stat_sig_vec <- function(x) {if(fun_stat_sig_UB_vec(x) != fun_stat_sig_LB_vec(x) || (x >= timeVec[which(timeVec==t0)-1] && x <= timeVec[which(timeVec==t0)+1])) 0 else fun_stat_sig_UB_vec(x)}
fun_stat_sig_vec <- Vectorize(fun_stat_sig_vec)
fun_stat_sig_vec
stat_sig_LB_vec
x_vals  <- seq(start, end, length.out=5*length(timeVec))
y_range     <- range(c(betahat_splinefun(x_vals), scb_ub_splinefun(x_vals), scb_lb_splinefun(x_vals)), na.rm=TRUE)
y_range     <- c(y_range[1] - diff(y_range)*0.12, y_range[2] + diff(y_range)*0.08)
y_range_fun <- function(x) y_range[1]+(y_range[2]-y_range[1])*(x-start)/(end-start)
curve(y_range_fun, from=start, to=end, lty=1,  xlab = "Event Time", ylab = "", col="white") #ylim =y_range,
ShadeBetween <- function(x1, x2, f1, f2, ...) {polygon(c(x1, rev(x2)), c(f1, rev(f2)), ...)}
polygon(
x = c(seq(t0, end, length.out = 100), rev(seq(t0, end, length.out = 100))),
y = c(scb_ub_splinefun(seq(t0, end, length.out = 100)), rev(scb_lb_splinefun(seq(t0, end, length.out = 100)))),
col =  adjustcolor("#48C9B0", alpha.f = 1),   # transparency
border = NA
)
polygon(
x = c(seq(start, t0, length.out = 100), rev(seq(start, t0, length.out = 100))),
y = c(scb_ub_splinefun(seq(start, t0, length.out = 100)), rev(scb_lb_splinefun(seq(start, t0, length.out = 100)))),
col = adjustcolor("#48C9B0", alpha.f = 0.7),   # transparency
border = NA
)
curve(betahat_splinefun, from=start, to=end, lty=1, add=TRUE, xlab = "Event Time", ylab = "", col="blue")
points(timeVec[which(timeVec<=t0)], betahat[which(timeVec<=t0)], pch = 16, col = rgb(0,0,1,alpha=0.4), cex=1)
points(timeVec[which(timeVec>t0)], betahat[which(timeVec>t0)], pch = 16, col = "blue", cex=1)
if(isTRUE(ci.pre)) {arrows(timeVec[which(timeVec<=t0)], ci_lower[which(timeVec<=t0)], timeVec[which(timeVec<=t0)], ci_upper[which(timeVec<=t0)], angle = 90, code = 3, length = 0.025, col = rgb(0,0,1,alpha=0.4));}
if(isTRUE(ci.post)) {arrows(timeVec[which(timeVec>t0)], ci_lower[which(timeVec>t0)], timeVec[which(timeVec>t0)], ci_upper[which(timeVec>t0)], angle = 90, code = 3, length = 0.025, col = "blue4");}
sig_pos_intervals <- matrix(ncol=2)
sig_neg_intervals <- matrix(ncol=2)
!isTRUE(ref.band.pre)
segments(x0=start, y0=0, x1=end, y1=0, lty=3, lwd=4, col="red")
ShadeBetween(timeVec[timeVec>=t0], timeVec[timeVec>=t0], honest_ub_splinefun(timeVec[timeVec>=t0]), honest_lb_splinefun(timeVec[timeVec>=t0]), col=rgb(1,0,0,alpha=0.4), border=NA)
ShadeBetween(timeVec[timeVec<=ta.ts], timeVec[timeVec<=ta.ts], honest_ub_splinefun(timeVec[timeVec<=ta.ts]), honest_lb_splinefun(timeVec[timeVec<=ta.ts]), col=rgb(1,0,0,alpha=0.2), border=NA)
roots_vec <- sort(unique(c(roots_vec, timeVec[which(timeVec==t0)-1], timeVec[which(timeVec==t0)+1])))
roots_vec <- roots_vec[roots_vec >= timeVec[which(timeVec==t0)+1] ]
for (i in 1:(length(roots_vec)-1) ) {
if ( fun_stat_sig_vec((roots_vec[i]+roots_vec[i+1])/2)==1 & roots_vec[i]>=t0 ) {
#rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA) #alpha=0.7
cat("Uniformly and Positively Significant Time Span: [", roots_vec[i], ",", roots_vec[i+1], "]\n")
sig_pos_intervals <- rbind(sig_pos_intervals, c(roots_vec[i], roots_vec[i+1]))
} else {
if (fun_stat_sig_vec((roots_vec[i]+roots_vec[i+1])/2)==-1 & roots_vec[i]>=t0) {
#rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA)
cat("Uniformly and Negatively Significant Time Span: [", roots_vec[i], ",", roots_vec[i+1], "]\n")
sig_neg_intervals <- rbind(sig_neg_intervals, c(roots_vec[i], roots_vec[i+1]))
}
}
}
roots_vec
abline(v=6.395976 )
1:(length(roots_vec)-1)
fun_stat_sig_vec((roots_vec[1]+roots_vec[1+1])/2)==1 & roots_vec[1]>=t0
fun_stat_sig_vec((roots_vec[1]+roots_vec[1+1])/2)==-1 & roots_vec[1]>=t0
fun_stat_sig_vec
roots_UB_vec
stat_sig_UB_vec
roots_LB_vec
stat_sig_LB_vec
fun_stat_sig_UB_vec(3)
fun_stat_sig_vec(3)
t0
fun_stat_sig_UB_vec(-3) != fun_stat_sig_LB_vec(x)
fun_stat_sig_UB_vec(3) != fun_stat_sig_LB_vec(3)
roots_UB_vec
stat_sig_UB_vec
fun_stat_sig_UB_vec(3)
fun_stat_sig_LB_vec(3)
roots_UB_vec
stat_sig_UB_vec
roots_LB_vec
stat_sig_LB_vec
# find the time spans of statistical significance
n.int <-200
roots_UB <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun         <- function(x) (scb_ub_splinefun(x)-honest_ub_splinefun(x))*(scb_lb_splinefun(x)-honest_ub_splinefun(x))
interval    <- c(t0+(i-1)*(end-t0)/n.int, t0+(i)*(end-t0)/n.int)
#interval    <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root        <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots_UB[i] <- if(inherits(root, "try-error")) {NA} else root
}
roots_UB <- sort(unique(roots_UB[!is.na(roots_UB)]))
roots_LB <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun         <- function(x) (scb_ub_splinefun(x)-honest_lb_splinefun(x))*(scb_lb_splinefun(x)-honest_lb_splinefun(x))
interval    <- c(t0+(i-1)*(end-t0)/n.int, t0+(i)*(end-t0)/n.int)
#interval    <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root        <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots_LB[i] <- if(inherits(root, "try-error")) {NA} else root
}
roots_LB <-  sort(unique(roots_LB[!is.na(roots_LB)]))
roots_UB_vec <- sort(unique(c(t0,roots_UB,end)))
roots_LB_vec <- sort(unique(c(t0,roots_LB,end)))
roots_vec    <- sort(unique(c(t0,end,roots_UB, roots_LB)))
# roots_UB_vec <- sort(unique(c(start,roots_UB,end)))
# roots_LB_vec <- sort(unique(c(start,roots_LB,end)))
# roots_vec    <- sort(unique(c(start,end,roots_UB, roots_LB)))
stat_sig_UB_vec <- rep(NA, length(roots_UB_vec)-1)
stat_sig_LB_vec <- rep(NA, length(roots_LB_vec)-1)
for (i in 1:(length(roots_UB_vec)-1)) {
test_point <- (roots_UB_vec[i]+roots_UB_vec[i+1])/2
scb_ub_sign <- sign(scb_ub_splinefun( test_point)-honest_ub_splinefun(test_point))
scb_lb_sign <- sign(scb_lb_splinefun( test_point)-honest_ub_splinefun(test_point))
stat_sig_UB_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
for (i in 1:(length(roots_LB_vec)-1)) {
test_point <- (roots_LB_vec[i]+roots_LB_vec[i+1])/2
scb_ub_sign <- sign(scb_ub_splinefun( test_point)-honest_lb_splinefun(test_point))
scb_lb_sign <- sign(scb_lb_splinefun( test_point)-honest_lb_splinefun(test_point))
stat_sig_LB_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
interval_fun <- function(x, a, b) {
if (length(b) != length(a) - 1) {
stop("Vector 'b' must be one element shorter than vector 'a'.")
}
for (i in 1:(length(a) - 1)) {
if (x >= a[i] && x <= a[i + 1]) {
return(b[i])
}
}
return(NA)
}
fun_stat_sig_UB_vec <- function(x) interval_fun(x, roots_UB_vec, stat_sig_UB_vec)
fun_stat_sig_LB_vec <- function(x) interval_fun(x, roots_LB_vec, stat_sig_LB_vec)
fun_stat_sig_UB_vec <- Vectorize(fun_stat_sig_UB_vec)
fun_stat_sig_LB_vec <- Vectorize(fun_stat_sig_LB_vec)
fun_stat_sig_vec <- function(x) {if(fun_stat_sig_UB_vec(x) != fun_stat_sig_LB_vec(x) || (x >= timeVec[which(timeVec==t0)-1] && x <= timeVec[which(timeVec==t0)+1])) 0 else fun_stat_sig_UB_vec(x)}
fun_stat_sig_vec <- Vectorize(fun_stat_sig_vec)
ShadeBetween(timeVec[timeVec>=t0], timeVec[timeVec>=t0], honest_ub_splinefun(timeVec[timeVec>=t0]), honest_lb_splinefun(timeVec[timeVec>=t0]), col=rgb(1,0,0,alpha=0.4), border=NA)
ShadeBetween(timeVec[timeVec<=ta.ts], timeVec[timeVec<=ta.ts], honest_ub_splinefun(timeVec[timeVec<=ta.ts]), honest_lb_splinefun(timeVec[timeVec<=ta.ts]), col=rgb(1,0,0,alpha=0.2), border=NA)
roots_vec <- sort(unique(c(roots_vec, timeVec[which(timeVec==t0)-1], timeVec[which(timeVec==t0)+1])))
roots_vec <- roots_vec[roots_vec >= timeVec[which(timeVec==t0)+1] ]
for (i in 1:(length(roots_vec)-1) ) {
if ( fun_stat_sig_vec((roots_vec[i]+roots_vec[i+1])/2)==1 & roots_vec[i]>=t0 ) {
#rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA) #alpha=0.7
cat("Uniformly and Positively Significant Time Span: [", roots_vec[i], ",", roots_vec[i+1], "]\n")
sig_pos_intervals <- rbind(sig_pos_intervals, c(roots_vec[i], roots_vec[i+1]))
} else {
if (fun_stat_sig_vec((roots_vec[i]+roots_vec[i+1])/2)==-1 & roots_vec[i]>=t0) {
#rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA)
cat("Uniformly and Negatively Significant Time Span: [", roots_vec[i], ",", roots_vec[i+1], "]\n")
sig_neg_intervals <- rbind(sig_neg_intervals, c(roots_vec[i], roots_vec[i+1]))
}
}
}
library(devtools)
document()
install()
library(devtools)
document()
install()
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
cat("The reference time is ", LWdata$t0, ". If not NULL, the input 'ta.ts' in function 'plot' should be smaller than this value.", sep="")
## simultaneous inference
par(cex.axis = 1.4, cex.lab = 1.4, cex.main = 1.4)
plot(fdid_scb_est, scale.legend=1.4)
title(ylab="Effects of Duty-to-Bargain Laws")
plot(fdid_scb_est, scale.legend=1.4, verbose = FALSE)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, verbose=FALSE)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4)
out <- capture.output(plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4))
out
capture.output(plot(fdid_scb_est, scale.legend=1.4))
out <- capture.output(plot(fdid_scb_est, scale.legend=1.4))
out
library(devtools)
document()
install()
library(pkgdown)
build_site()
library(pkgdown)
build_site()
build_site()
library(pkgdown)
build_site()
remove.packages("fdid")
# install.packages("devtools")
devtools::install_github("ccfang2/fdid")
library(fdid)
data(Gdata)
fdid_scb_est <- fdid_scb(beta=Gdata$beta, cov=Gdata$cov, t0=Gdata$t0)
EventStudyPlot_Classical(fdid_scb_est, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, pos.legend="bottom", scale.legend=1.4, note.pre=FALSE)
plot(fdid_scb_est, ta.ts=-3, ta.s=c(1.55,2.55), pos.legend="bottom", scale.legend=1.4, ci.post=TRUE, ref.band.pre = TRUE)
plot(fdid_scb_est, frmtr.m=c(0.3,0.3), pos.legend="bottom", scale.legend=1.4, ci.post=TRUE, ref.band.pre = TRUE)
library(fdid)
library(devtools)
document()
install()
library(devtools)
document()
install()
library(pkgdown)
build_site()
library(pkgdown)
build_site()
