build_site()
library(pkgdown)
build_site()
remove.packages("fdid")
# install.packages("devtools")
devtools::install_github("ccfang2/fdid")
is.null(c(3,NULL))
frmtr.m=c(3,NULL)
!is.null(frmtr.m) && (is.null(frmtr.m[1]) || is.null(frmtr.m[2]))
!is.null(frmtr.m) && (is.null(frmtr.m[1]) | is.null(frmtr.m[2]))
!is.null(frmtr.m)
(is.null(frmtr.m[1]) || is.null(frmtr.m[2]))
is.null(frmtr.m[1])
is.null(frmtr.m[2]))
is.null(frmtr.m[2])
frmtr.m=c(3,NULL)
frmtr.m[2]
!is.null(frmtr.m) && (is.na(frmtr.m[1]) || is.na(frmtr.m[2]))
library(devtools)
document()
install()
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
cat("The reference time is ", LWdata$t0, ". If not NULL, the input 'ta.ts' in function 'plot' should be smaller than this value.", sep="")
par(cex.axis = 1.4, cex.lab = 1.4, cex.main = 1.4)
plot(fdid_scb_est, scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=NULL)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=c(2,NULL))
length(c(2,NULL))
length(c(3,NA))
library(devtools)
document()
install()
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=c(3,NULL))
length(c(3,NULL))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=c(3,NA))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, frmtr.m=c(3,NULL))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, frmtr.m=c(3,NA))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=c(3))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=c(3,3))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, frmtr.m=c(3,3))
plot(fdid_scb_est, ta.ts=-2, scale.legend=1.4, frmtr.m=c(3,3))
ta.s=c(3,NA)
is.na(ta.s)
any(is.na(ta.s))
library(devtools)
document()
library(devtools)
document()
install()
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=c(1,NULL))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4,ta.s=c(1,NA))
library(devtools)
document()
install()
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=c(1,NULL))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=c(1,NA))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, ta.s=c(1,1))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, frmtr.m = c(1,NULL))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, frmtr.m = c(1,NA))
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4, frmtr.m = c(1,1))
library(pkgdown)
build_site()
library(pkgdown)
build_site()
remove.packages("fdid")
# install.packages("devtools")
devtools::install_github("ccfang2/fdid")
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
View(fdid_scb_est)
library(devtools)
document()
install()
library(fdid)
data(LWdata)
object <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
ta.ts=NULL
ta.s=NULL
frmtr.m=NULL
ref.band.pre=TRUE
note.pre=TRUE
note.post=TRUE
ci.pre=FALSE
ci.post=FALSE
pos.legend="top"
scale.legend=1
verbose=TRUE
# check conditions
if (!base::inherits(object,"fdid_scb")) stop("The input 'object' should be an output of function 'fdid_scb'.")
if (!is.null(ta.ts) && (!is.numeric(ta.ts) || length(ta.ts) != 1)) stop("The input 'ta.ts' should be either NULL or a numeric scalar.")
if (!is.null(ta.ts) && !(ta.ts %in% object$scb$event_t[which(object$scb$event_t<=object$data$t0)])) stop("If not NULL, the input 'ta.ts' should be among the pre-treatment event time in 'object'.")
if (!is.null(ta.ts) && ta.ts == object$scb$event_t[1] && !all(sapply(list( frmtr.m), is.null))) stop("If 'ta.ts' is defined to be the first event time, 'frmtr.m' must be NULL, because there is no available data for computing pre-trend differences.")
if (!is.null(ta.s) && any(is.na(ta.s))) stop("The input 'ta.s' cannot contain NA.")
if (!is.null(ta.s) && (!is.numeric(ta.s) || length(ta.s) != 2 || any(ta.s <0) )) stop("The input 'ta.s' should be either NULL or a numeric non-negative vector of length two.")
if (!is.null(frmtr.m) && any(is.na(frmtr.m))) stop("The input 'frmtr.m' cannot contain NA.")
if (!is.null(frmtr.m) && (!is.numeric(frmtr.m) || length(frmtr.m) != 2 || any(frmtr.m<0) )) stop("The input 'frmtr.m' should be either NULL or a numeric non-negative vector of length two.")
if (!is.logical(ref.band.pre)) stop("The input 'ref.band.pre' should be logical.")
if (!is.logical(note.pre)) stop("The input 'note.pre' should be logical.")
if (!is.logical(note.post)) stop("The input 'note.post' should be logical.")
if (!is.logical(ci.pre)) stop("The input 'ci.pre' should be logical.")
if (!is.logical(ci.post)) stop("The input 'ci.post' should be logical.")
if (!is.null(pos.legend) && !pos.legend %in% c("top", "bottom")) stop("The input 'pos.legend' must be 'top', 'bottom', or NULL.")
if (!is.numeric(scale.legend) || length(scale.legend) != 1 || scale.legend <= 0 || !is.finite(scale.legend)) stop("The input 'scale.legend' must be a positive number.")
if (!is.logical(verbose)) stop("The input 'verbose' should be logical.")
# extract data from object
betahat <- object$data$beta[,1]
covhat  <- object$data$cov
timeVec <- object$data$beta[,2]
betahat_splinefun <- object$scb$betahat
scb_ub_splinefun  <- object$scb$scb_ub
scb_lb_splinefun  <- object$scb$scb_lb
ci_upper <- object$ci[,"ci_upper"]
ci_lower <- object$ci[,"ci_lower"]
start                     <- min(object$data$beta[,2])
end                       <- max(object$data$beta[,2])
t0                        <- object$data$t0
ci.alpha                  <- object$data$ci.alpha
scb.pre.alpha             <- object$data$scb.pre.alpha
scb.post.alpha            <- object$data$scb.post.alpha
if (is.null(ta.ts)) ta.ts <- t0
ta.ts==t0 & is.null(frmtr.m)
n.int <- 200
roots <- vector("numeric", length = n.int)
i=1
fun      <- function(x) scb_ub_splinefun(x)*scb_lb_splinefun(x)
interval <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
interval
for (i in 1:n.int) {
fun      <- function(x) scb_ub_splinefun(x)*scb_lb_splinefun(x)
interval <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root     <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots[i] <- if(inherits(root, "try-error")) {NA} else root
}
roots <- sort(unique(roots[!is.na(roots)]))
roots
sort(unique(c(start,roots,end)))
roots_vec    <- sort(unique(c(start,roots,end)))
stat_sig_vec <- rep(NA, length(roots_vec)-1)
stat_sig_vec
for (i in 1:(length(roots_vec)-1)) {
test_point      <- (roots_vec[i]+roots_vec[i+1])/2
scb_ub_sign     <- sign(scb_ub_splinefun( test_point))
scb_lb_sign     <- sign(scb_lb_splinefun( test_point))
stat_sig_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
stat_sig_vec
x_vals  <- seq(start, end, length.out = 5*length(timeVec))
y_range     <- range(c(betahat_splinefun(x_vals), scb_ub_splinefun(x_vals), scb_lb_splinefun(x_vals)), na.rm=TRUE)
y_range     <- c(y_range[1] - diff(y_range)*0.12, y_range[2] + diff(y_range)*0.08)
y_range_fun <- function(x) y_range[1]+(y_range[2]-y_range[1])*(x-start)/(end-start)
curve(y_range_fun, from=start, to=end, lty=1,  xlab = "Event Time", ylab = "", col="white") #ylim =y_range,
ShadeBetween <- function(x1, x2, f1, f2, ...) {polygon(c(x1, rev(x2)), c(f1, rev(f2)), ...)}
band_grid    <- seq(start, end, length.out = 400)
ub <- scb_ub_splinefun(seq(start, end, length.out = 400))
lb <- scb_lb_splinefun(seq(start, end, length.out = 400))
polygon(
x = c(seq(t0, end, length.out = 100), rev(seq(t0, end, length.out = 100))),
y = c(scb_ub_splinefun(seq(t0, end, length.out = 100)), rev(scb_lb_splinefun(seq(t0, end, length.out = 100)))),
col =  adjustcolor("#48C9B0", alpha.f = 1),
border = NA
)
polygon(
x = c(seq(start, t0, length.out = 100), rev(seq(start, t0, length.out = 100))),
y = c(scb_ub_splinefun(seq(start, t0, length.out = 100)), rev(scb_lb_splinefun(seq(start, t0, length.out = 100)))),
col = adjustcolor("#48C9B0", alpha.f = 0.7),
border = NA
)
curve(betahat_splinefun, from=start, to=end, lty=1, add=TRUE, xlab = "Event Time", ylab = "", col="blue") #ylim =y_range,
points(timeVec[which(timeVec<=t0)], betahat[which(timeVec<=t0)], pch = 16, col = rgb(0,0,1,alpha=0.4), cex=1)
points(timeVec[which(timeVec>t0)], betahat[which(timeVec>t0)], pch = 16, col = "blue", cex=1)
if(isTRUE(ci.pre)) {arrows(timeVec[which(timeVec<=t0)], ci_lower[which(timeVec<=t0)], timeVec[which(timeVec<=t0)], ci_upper[which(timeVec<=t0)], angle = 90, code = 3, length = 0.025, col = rgb(0,0,1,alpha=0.4));}
if(isTRUE(ci.post)) {arrows(timeVec[which(timeVec>t0)], ci_lower[which(timeVec>t0)], timeVec[which(timeVec>t0)], ci_upper[which(timeVec>t0)], angle = 90, code = 3, length = 0.025, col = "blue4");}
!isTRUE(ref.band.pre)
segments(x0=start, y0=0, x1=end, y1=0, lty=3, lwd=4, col="red")
sort(unique(c(roots_vec, timeVec[which(timeVec==t0)-1], timeVec[which(timeVec==t0)+1])))
roots_vec_temp    <- sort(unique(c(roots_vec, timeVec[which(timeVec==t0)-1], timeVec[which(timeVec==t0)+1])))
data.frame(left  = head(roots_vec_temp, -1), right = tail(roots_vec_temp, -1))
library(fdid)
data(Gdata)
Gdata$beta[,"event_t"] <- Gdata$beta[,"event_t"]- Gdata$t0 #Recenter the event time on 0
fdid_scb_est <- fdid_scb(beta=Gdata$beta, cov=Gdata$cov, t0=0)
object <- fdid_scb_est
ta.ts=NULL
ta.s=NULL
frmtr.m=NULL
ref.band.pre=TRUE
note.pre=TRUE
note.post=TRUE
ci.pre=FALSE
ci.post=FALSE
pos.legend="top"
scale.legend=1
verbose=TRUE
# check conditions
if (!base::inherits(object,"fdid_scb")) stop("The input 'object' should be an output of function 'fdid_scb'.")
if (!is.null(ta.ts) && (!is.numeric(ta.ts) || length(ta.ts) != 1)) stop("The input 'ta.ts' should be either NULL or a numeric scalar.")
if (!is.null(ta.ts) && !(ta.ts %in% object$scb$event_t[which(object$scb$event_t<=object$data$t0)])) stop("If not NULL, the input 'ta.ts' should be among the pre-treatment event time in 'object'.")
if (!is.null(ta.ts) && ta.ts == object$scb$event_t[1] && !all(sapply(list( frmtr.m), is.null))) stop("If 'ta.ts' is defined to be the first event time, 'frmtr.m' must be NULL, because there is no available data for computing pre-trend differences.")
if (!is.null(ta.s) && any(is.na(ta.s))) stop("The input 'ta.s' cannot contain NA.")
if (!is.null(ta.s) && (!is.numeric(ta.s) || length(ta.s) != 2 || any(ta.s <0) )) stop("The input 'ta.s' should be either NULL or a numeric non-negative vector of length two.")
if (!is.null(frmtr.m) && any(is.na(frmtr.m))) stop("The input 'frmtr.m' cannot contain NA.")
if (!is.null(frmtr.m) && (!is.numeric(frmtr.m) || length(frmtr.m) != 2 || any(frmtr.m<0) )) stop("The input 'frmtr.m' should be either NULL or a numeric non-negative vector of length two.")
if (!is.logical(ref.band.pre)) stop("The input 'ref.band.pre' should be logical.")
if (!is.logical(note.pre)) stop("The input 'note.pre' should be logical.")
if (!is.logical(note.post)) stop("The input 'note.post' should be logical.")
if (!is.logical(ci.pre)) stop("The input 'ci.pre' should be logical.")
if (!is.logical(ci.post)) stop("The input 'ci.post' should be logical.")
if (!is.null(pos.legend) && !pos.legend %in% c("top", "bottom")) stop("The input 'pos.legend' must be 'top', 'bottom', or NULL.")
if (!is.numeric(scale.legend) || length(scale.legend) != 1 || scale.legend <= 0 || !is.finite(scale.legend)) stop("The input 'scale.legend' must be a positive number.")
if (!is.logical(verbose)) stop("The input 'verbose' should be logical.")
# extract data from object
betahat <- object$data$beta[,1]
covhat  <- object$data$cov
timeVec <- object$data$beta[,2]
betahat_splinefun <- object$scb$betahat
scb_ub_splinefun  <- object$scb$scb_ub
scb_lb_splinefun  <- object$scb$scb_lb
ci_upper <- object$ci[,"ci_upper"]
ci_lower <- object$ci[,"ci_lower"]
start                     <- min(object$data$beta[,2])
end                       <- max(object$data$beta[,2])
t0                        <- object$data$t0
ci.alpha                  <- object$data$ci.alpha
scb.pre.alpha             <- object$data$scb.pre.alpha
scb.post.alpha            <- object$data$scb.post.alpha
if (is.null(ta.ts)) ta.ts <- t0
ta.ts==t0 & is.null(frmtr.m)
n.int <- 200
roots <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun      <- function(x) scb_ub_splinefun(x)*scb_lb_splinefun(x)
interval <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root     <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots[i] <- if(inherits(root, "try-error")) {NA} else root
}
#roots <- roots[!is.na(roots)]
roots <- sort(unique(roots[!is.na(roots)]))
roots
roots_vec    <- sort(unique(c(start,roots,end)))
stat_sig_vec <- rep(NA, length(roots_vec)-1)
for (i in 1:(length(roots_vec)-1)) {
test_point      <- (roots_vec[i]+roots_vec[i+1])/2
scb_ub_sign     <- sign(scb_ub_splinefun( test_point))
scb_lb_sign     <- sign(scb_lb_splinefun( test_point))
stat_sig_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
x_vals  <- seq(start, end, length.out = 5*length(timeVec))
y_range     <- range(c(betahat_splinefun(x_vals), scb_ub_splinefun(x_vals), scb_lb_splinefun(x_vals)), na.rm=TRUE)
y_range     <- c(y_range[1] - diff(y_range)*0.12, y_range[2] + diff(y_range)*0.08)
y_range_fun <- function(x) y_range[1]+(y_range[2]-y_range[1])*(x-start)/(end-start)
curve(y_range_fun, from=start, to=end, lty=1,  xlab = "Event Time", ylab = "", col="white") #ylim =y_range,
ShadeBetween <- function(x1, x2, f1, f2, ...) {polygon(c(x1, rev(x2)), c(f1, rev(f2)), ...)}
band_grid    <- seq(start, end, length.out = 400)
ub <- scb_ub_splinefun(seq(start, end, length.out = 400))
lb <- scb_lb_splinefun(seq(start, end, length.out = 400))
polygon(
x = c(seq(t0, end, length.out = 100), rev(seq(t0, end, length.out = 100))),
y = c(scb_ub_splinefun(seq(t0, end, length.out = 100)), rev(scb_lb_splinefun(seq(t0, end, length.out = 100)))),
col =  adjustcolor("#48C9B0", alpha.f = 1),
border = NA
)
polygon(
x = c(seq(start, t0, length.out = 100), rev(seq(start, t0, length.out = 100))),
y = c(scb_ub_splinefun(seq(start, t0, length.out = 100)), rev(scb_lb_splinefun(seq(start, t0, length.out = 100)))),
col = adjustcolor("#48C9B0", alpha.f = 0.7),
border = NA
)
curve(betahat_splinefun, from=start, to=end, lty=1, add=TRUE, xlab = "Event Time", ylab = "", col="blue") #ylim =y_range,
points(timeVec[which(timeVec<=t0)], betahat[which(timeVec<=t0)], pch = 16, col = rgb(0,0,1,alpha=0.4), cex=1)
points(timeVec[which(timeVec>t0)], betahat[which(timeVec>t0)], pch = 16, col = "blue", cex=1)
if(isTRUE(ci.pre)) {arrows(timeVec[which(timeVec<=t0)], ci_lower[which(timeVec<=t0)], timeVec[which(timeVec<=t0)], ci_upper[which(timeVec<=t0)], angle = 90, code = 3, length = 0.025, col = rgb(0,0,1,alpha=0.4));}
if(isTRUE(ci.post)) {arrows(timeVec[which(timeVec>t0)], ci_lower[which(timeVec>t0)], timeVec[which(timeVec>t0)], ci_upper[which(timeVec>t0)], angle = 90, code = 3, length = 0.025, col = "blue4");}
!isTRUE(ref.band.pre)
segments(x0=start, y0=0, x1=end, y1=0, lty=3, lwd=4, col="red")
sort(unique(c(roots_vec, timeVec[which(timeVec==t0)-1], timeVec[which(timeVec==t0)+1])))
roots_vec_temp    <- sort(unique(c(roots_vec, timeVec[which(timeVec==t0)-1], timeVec[which(timeVec==t0)+1])))
data.frame(left  = head(roots_vec_temp, -1), right = tail(roots_vec_temp, -1))
roots_vec
sort(unique(c(roots_vec, timeVec[which(timeVec==t0)])))
roots_vec_temp    <- sort(unique(c(roots_vec, timeVec[which(timeVec==t0)])))
intervals         <- data.frame(left  = head(roots_vec_temp, -1), right = tail(roots_vec_temp, -1))
intervals
stat_sig_vec_temp <- rep(NA, nrow(intervals))
for (i in 1:nrow(intervals)) {
l <- intervals$left[i]
r <- intervals$right[i]
# if (l >= timeVec[which(timeVec==t0)-1] && r <= timeVec[which(timeVec==t0)+1]) {
#   stat_sig_vec_temp[i] <- 0
# } else {
idx <- which(roots_vec <= l)[length(which(roots_vec  <= l))]
stat_sig_vec_temp[i] <- stat_sig_vec[idx]
# }
}
stat_sig_vec <- stat_sig_vec_temp
roots_vec    <- roots_vec_temp
for (i in 1:(length(roots_vec)-1)) {
if (stat_sig_vec[i]==1 & roots_vec[i]>=t0 ) {
#rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA) #alpha=0.7
if (isTRUE(verbose)) cat("Uniformly and Positively Significant Time Span: [", roots_vec[i], ",", roots_vec[i+1], "]\n")
#sig_pos_intervals <- rbind(sig_pos_intervals, c(roots_vec[i], roots_vec[i+1]))
} else {
if (stat_sig_vec[i]==-1 & roots_vec[i]>=t0 ) {
#rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA)
if (isTRUE(verbose)) cat("Uniformly and Negatively Significant Time Span: [", roots_vec[i], ",", roots_vec[i+1], "]\n")
#sig_neg_intervals <- rbind(sig_neg_intervals, c(roots_vec[i], roots_vec[i+1]))
}
}
}
ta.ts=-2
ta.s=NULL
frmtr.m=NULL
ta.s=c(1.55,2.55)
ref.band.pre=TRUE
note.pre=TRUE
note.post=TRUE
ci.pre=FALSE
ci.post=FALSE
pos.legend="top"
scale.legend=1
verbose=TRUE
# check conditions
if (!base::inherits(object,"fdid_scb")) stop("The input 'object' should be an output of function 'fdid_scb'.")
if (!is.null(ta.ts) && (!is.numeric(ta.ts) || length(ta.ts) != 1)) stop("The input 'ta.ts' should be either NULL or a numeric scalar.")
if (!is.null(ta.ts) && !(ta.ts %in% object$scb$event_t[which(object$scb$event_t<=object$data$t0)])) stop("If not NULL, the input 'ta.ts' should be among the pre-treatment event time in 'object'.")
if (!is.null(ta.ts) && ta.ts == object$scb$event_t[1] && !all(sapply(list( frmtr.m), is.null))) stop("If 'ta.ts' is defined to be the first event time, 'frmtr.m' must be NULL, because there is no available data for computing pre-trend differences.")
if (!is.null(ta.s) && any(is.na(ta.s))) stop("The input 'ta.s' cannot contain NA.")
if (!is.null(ta.s) && (!is.numeric(ta.s) || length(ta.s) != 2 || any(ta.s <0) )) stop("The input 'ta.s' should be either NULL or a numeric non-negative vector of length two.")
if (!is.null(frmtr.m) && any(is.na(frmtr.m))) stop("The input 'frmtr.m' cannot contain NA.")
if (!is.null(frmtr.m) && (!is.numeric(frmtr.m) || length(frmtr.m) != 2 || any(frmtr.m<0) )) stop("The input 'frmtr.m' should be either NULL or a numeric non-negative vector of length two.")
if (!is.logical(ref.band.pre)) stop("The input 'ref.band.pre' should be logical.")
if (!is.logical(note.pre)) stop("The input 'note.pre' should be logical.")
if (!is.logical(note.post)) stop("The input 'note.post' should be logical.")
if (!is.logical(ci.pre)) stop("The input 'ci.pre' should be logical.")
if (!is.logical(ci.post)) stop("The input 'ci.post' should be logical.")
if (!is.null(pos.legend) && !pos.legend %in% c("top", "bottom")) stop("The input 'pos.legend' must be 'top', 'bottom', or NULL.")
if (!is.numeric(scale.legend) || length(scale.legend) != 1 || scale.legend <= 0 || !is.finite(scale.legend)) stop("The input 'scale.legend' must be a positive number.")
if (!is.logical(verbose)) stop("The input 'verbose' should be logical.")
# extract data from object
betahat <- object$data$beta[,1]
covhat  <- object$data$cov
timeVec <- object$data$beta[,2]
betahat_splinefun <- object$scb$betahat
scb_ub_splinefun  <- object$scb$scb_ub
scb_lb_splinefun  <- object$scb$scb_lb
ci_upper <- object$ci[,"ci_upper"]
ci_lower <- object$ci[,"ci_lower"]
start                     <- min(object$data$beta[,2])
end                       <- max(object$data$beta[,2])
t0                        <- object$data$t0
ci.alpha                  <- object$data$ci.alpha
scb.pre.alpha             <- object$data$scb.pre.alpha
scb.post.alpha            <- object$data$scb.post.alpha
if (is.null(ta.ts)) ta.ts <- t0
ta.ts==t0 & is.null(frmtr.m)
is.null(frmtr.m)
if( is.null(frmtr.m)) {
if(is.null(ta.s)) {
ta_ub <- ci_upper[names(ci_upper)==as.character(ta.ts)]
ta_lb <- ci_lower[names(ci_lower)==as.character(ta.ts)]
} else {
ta.s1 <- ta.s[1]
ta.s2 <- ta.s[2]
# ta_ub <- if(is.na(ta.s1)) ci_upper[names(ci_upper)==as.character(ta.ts)] else betahat[which(timeVec==ta.ts)]+ta.s1*sqrt(diag(covhat)[which(timeVec==ta.ts)])
# ta_lb <- if(is.na(ta.s2)) ci_lower[names(ci_lower)==as.character(ta.ts)] else betahat[which(timeVec==ta.ts)]-ta.s2*sqrt(diag(covhat)[which(timeVec==ta.ts)])
ta_ub <- betahat[which(timeVec==ta.ts)]+ta.s1*sqrt(diag(covhat)[which(timeVec==ta.ts)])
ta_lb <- betahat[which(timeVec==ta.ts)]-ta.s2*sqrt(diag(covhat)[which(timeVec==ta.ts)])
}
honest_ub_splinefun <- function(x) ta_ub
honest_lb_splinefun <- function(x) ta_lb
honest_ub_splinefun <- Vectorize(honest_ub_splinefun)
honest_lb_splinefun <- Vectorize(honest_lb_splinefun)
}
!is.null(frmtr.m)
n.int <-200
roots_UB <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun         <- function(x) (scb_ub_splinefun(x)-honest_ub_splinefun(x))*(scb_lb_splinefun(x)-honest_ub_splinefun(x))
interval    <- c(t0+(i-1)*(end-t0)/n.int, t0+(i)*(end-t0)/n.int)
#interval    <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root        <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots_UB[i] <- if(inherits(root, "try-error")) {NA} else root
}
roots_UB <- sort(unique(roots_UB[!is.na(roots_UB)]))
roots_LB <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun         <- function(x) (scb_ub_splinefun(x)-honest_lb_splinefun(x))*(scb_lb_splinefun(x)-honest_lb_splinefun(x))
interval    <- c(t0+(i-1)*(end-t0)/n.int, t0+(i)*(end-t0)/n.int)
#interval    <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root        <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots_LB[i] <- if(inherits(root, "try-error")) {NA} else root
}
roots_LB <-  sort(unique(roots_LB[!is.na(roots_LB)]))
roots_UB_vec <- sort(unique(c(t0,roots_UB,end)))
roots_LB_vec <- sort(unique(c(t0,roots_LB,end)))
roots_vec    <- sort(unique(c(t0,end,roots_UB, roots_LB)))
# roots_UB_vec <- sort(unique(c(start,roots_UB,end)))
# roots_LB_vec <- sort(unique(c(start,roots_LB,end)))
# roots_vec    <- sort(unique(c(start,end,roots_UB, roots_LB)))
stat_sig_UB_vec <- rep(NA, length(roots_UB_vec)-1)
stat_sig_LB_vec <- rep(NA, length(roots_LB_vec)-1)
for (i in 1:(length(roots_UB_vec)-1)) {
test_point <- (roots_UB_vec[i]+roots_UB_vec[i+1])/2
scb_ub_sign <- sign(scb_ub_splinefun( test_point)-honest_ub_splinefun(test_point))
scb_lb_sign <- sign(scb_lb_splinefun( test_point)-honest_ub_splinefun(test_point))
stat_sig_UB_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
for (i in 1:(length(roots_LB_vec)-1)) {
test_point <- (roots_LB_vec[i]+roots_LB_vec[i+1])/2
scb_ub_sign <- sign(scb_ub_splinefun( test_point)-honest_lb_splinefun(test_point))
scb_lb_sign <- sign(scb_lb_splinefun( test_point)-honest_lb_splinefun(test_point))
stat_sig_LB_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
interval_fun <- function(x, a, b) {
if (length(b) != length(a) - 1) {
stop("Vector 'b' must be one element shorter than vector 'a'.")
}
for (i in 1:(length(a) - 1)) {
if (x >= a[i] && x <= a[i + 1]) {
return(b[i])
}
}
return(NA)
}
fun_stat_sig_UB_vec <- function(x) interval_fun(x, roots_UB_vec, stat_sig_UB_vec)
fun_stat_sig_LB_vec <- function(x) interval_fun(x, roots_LB_vec, stat_sig_LB_vec)
fun_stat_sig_UB_vec <- Vectorize(fun_stat_sig_UB_vec)
fun_stat_sig_LB_vec <- Vectorize(fun_stat_sig_LB_vec)
fun_stat_sig_vec <- function(x) {if(fun_stat_sig_UB_vec(x) != fun_stat_sig_LB_vec(x)) 0 else fun_stat_sig_UB_vec(x)}
fun_stat_sig_vec <- Vectorize(fun_stat_sig_vec)
x_vals  <- seq(start, end, length.out=5*length(timeVec))
y_range     <- range(c(betahat_splinefun(x_vals), scb_ub_splinefun(x_vals), scb_lb_splinefun(x_vals)), na.rm=TRUE)
y_range     <- c(y_range[1] - diff(y_range)*0.12, y_range[2] + diff(y_range)*0.08)
y_range_fun <- function(x) y_range[1]+(y_range[2]-y_range[1])*(x-start)/(end-start)
curve(y_range_fun, from=start, to=end, lty=1,  xlab = "Event Time", ylab = "", col="white") #ylim =y_range,
ShadeBetween <- function(x1, x2, f1, f2, ...) {polygon(c(x1, rev(x2)), c(f1, rev(f2)), ...)}
polygon(
x = c(seq(t0, end, length.out = 100), rev(seq(t0, end, length.out = 100))),
y = c(scb_ub_splinefun(seq(t0, end, length.out = 100)), rev(scb_lb_splinefun(seq(t0, end, length.out = 100)))),
col =  adjustcolor("#48C9B0", alpha.f = 1),   # transparency
border = NA
)
polygon(
x = c(seq(start, t0, length.out = 100), rev(seq(start, t0, length.out = 100))),
y = c(scb_ub_splinefun(seq(start, t0, length.out = 100)), rev(scb_lb_splinefun(seq(start, t0, length.out = 100)))),
col = adjustcolor("#48C9B0", alpha.f = 0.7),   # transparency
border = NA
)
curve(betahat_splinefun, from=start, to=end, lty=1, add=TRUE, xlab = "Event Time", ylab = "", col="blue")
points(timeVec[which(timeVec<=t0)], betahat[which(timeVec<=t0)], pch = 16, col = rgb(0,0,1,alpha=0.4), cex=1)
points(timeVec[which(timeVec>t0)], betahat[which(timeVec>t0)], pch = 16, col = "blue", cex=1)
if(isTRUE(ci.pre)) {arrows(timeVec[which(timeVec<=t0)], ci_lower[which(timeVec<=t0)], timeVec[which(timeVec<=t0)], ci_upper[which(timeVec<=t0)], angle = 90, code = 3, length = 0.025, col = rgb(0,0,1,alpha=0.4));}
if(isTRUE(ci.post)) {arrows(timeVec[which(timeVec>t0)], ci_lower[which(timeVec>t0)], timeVec[which(timeVec>t0)], ci_upper[which(timeVec>t0)], angle = 90, code = 3, length = 0.025, col = "blue4");}
!isTRUE(ref.band.pre)
segments(x0=start, y0=0, x1=end, y1=0, lty=3, lwd=4, col="red")
ShadeBetween(timeVec[timeVec>=t0], timeVec[timeVec>=t0], honest_ub_splinefun(timeVec[timeVec>=t0]), honest_lb_splinefun(timeVec[timeVec>=t0]), col=rgb(1,0,0,alpha=0.4), border=NA)
ShadeBetween(timeVec[timeVec<=ta.ts], timeVec[timeVec<=ta.ts], honest_ub_splinefun(timeVec[timeVec<=ta.ts]), honest_lb_splinefun(timeVec[timeVec<=ta.ts]), col=rgb(1,0,0,alpha=0.2), border=NA)
roots_vec <- sort(unique(c(roots_vec, timeVec[which(timeVec==t0)])))
roots_vec
roots_vec[roots_vec >= timeVec[which(timeVec==t0)+1] ]
roots_vec[roots_vec >= timeVec[which(timeVec==t0)] ]
roots_vec <- roots_vec[roots_vec >= timeVec[which(timeVec==t0)] ]
for (i in 1:(length(roots_vec)-1) ) {
if ( fun_stat_sig_vec((roots_vec[i]+roots_vec[i+1])/2)==1 & roots_vec[i]>=t0 ) {
#rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA) #alpha=0.7
if(isTRUE(verbose)) cat("Uniformly and Positively Significant Time Span: [", roots_vec[i], ",", roots_vec[i+1], "]\n")
#sig_pos_intervals <- rbind(sig_pos_intervals, c(roots_vec[i], roots_vec[i+1]))
} else {
if (fun_stat_sig_vec((roots_vec[i]+roots_vec[i+1])/2)==-1 & roots_vec[i]>=t0) {
#rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA)
if(isTRUE(verbose)) cat("Uniformly and Negatively Significant Time Span: [", roots_vec[i], ",", roots_vec[i+1], "]\n")
#sig_neg_intervals <- rbind(sig_neg_intervals, c(roots_vec[i], roots_vec[i+1]))
}
}
}
library(devtools)
document()
install()
library(devtools)
document()
install()
library(pkgdown)
build_site()
library(devtools)
document()
install()
library(fdid)
library(fdid)
data(Gdata)
Gdata$beta[,"event_t"] <- Gdata$beta[,"event_t"]- Gdata$t0 #Recenter the event time on 0
fdid_scb_est <- fdid_scb(beta=Gdata$beta, cov=Gdata$cov, t0=0)
par(cex.axis = 1.4, cex.lab = 1.4, cex.main = 1.4, family="Times")
EventStudyPlot_Classical(fdid_scb_est, pos.legend="bottom", scale.legend=1.4)
remove.packages("fdid")
# install.packages("devtools")
devtools::install_github("ccfang2/fdid")
pkgdown::build_site()
