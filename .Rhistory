plot(fdid_scb_est, pos.legend="bottom", scale.legend=1.4)
dev.off()
par(family="Times")
pdf("plot_scb_ta.pdf", width = 8, height = 6)
plot(fdid_scb_est, ta.t0 = -3, pos.legend="bottom", scale.legend=1.4)
dev.off()
par(family="Times")
pdf("plot_scb_frm.pdf", width = 8, height = 6)
plot(fdid_scb_est, frm.mbar = 1, pos.legend="bottom", scale.legend=1.4)
dev.off()
par(family="Times")
pdf("plot_scb_ftr.pdf", width = 8, height = 6)
plot(fdid_scb_est, ftr.m = 2, pos.legend="bottom", scale.legend=1.4)
dev.off()
getwd()
plot(fdid_scb_est, ta.t0 = -3, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.t0 = -3, ta.s=3, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.t0 = -3, ta.s=4, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.t0 = -9, ta.s=4, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.t0 = -9, ta.s=2, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.t0 = -9, ta.s=2.5, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.t0 = -9, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, frm.mbar = 1, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, frm.mbar = 2, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, frm.mbar = 2.5, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, frm.mbar = 4, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, frm.mbar = 4.2, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ftr.m = 4, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ftr.m = 10, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ftr.m = 15, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.t0 = -9, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, frm.mbar = 4.2, pos.legend="bottom", scale.legend=1.4)
par(family="Times")
pdf("plot_scb.pdf", width = 8, height = 6)
plot(fdid_scb_est, pos.legend="bottom", scale.legend=1.4)
dev.off()
par(family="Times")
pdf("plot_scb_ta.pdf", width = 8, height = 6)
plot(fdid_scb_est, ta.t0 = -9, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
dev.off()
par(family="Times")
pdf("plot_scb_frm.pdf", width = 8, height = 6)
plot(fdid_scb_est, frm.mbar = 1, pos.legend="bottom", scale.legend=1.4)
dev.off()
par(family="Times")
pdf("plot_scb_ftr.pdf", width = 8, height = 6)
plot(fdid_scb_est, ftr.m = 2, pos.legend="bottom", scale.legend=1.4)
dev.off()
library(pdftools)
pdf_convert("plot_scb.pdf", format = "png", filenames = "plot_scb.png", dpi = 300)
pdf_convert("plot_scb_ta.pdf", format = "png", filenames = "plot_scb_ta.png", dpi = 300)
pdf_convert("plot_scb_frm.pdf", format = "png", filenames = "plot_scb_frm.png", dpi = 300)
pdf_convert("plot_scb_ftr.pdf", format = "png", filenames = "plot_scb_ftr.png", dpi = 300)
library(pkgdown)
build_site()
build_site()
library(pkgdown)
build_site()
build_site()
build_site()
library(pkgdown)
build_site()
library(pkgdown)
build_site()
build_site()
build_site()
remove.packages("fdid")
devtools::install_github("ccfang2/fdid")
###################################################
## libraries
###################################################
library("ffscb") ## https://www.dliebl.com/ffscb/
library("rngtools")
library("rstudioapi")
library("pbmcapply")
library("xtable")
library("splines2") # for naturalSpline
library("Rcpp")
library("RcppArmadillo")
###################################################
## setups
###################################################
mydir <- dirname(rstudioapi::getActiveDocumentContext()$path) ## set the file path to the current file
setwd(mydir)
core.c <- parallel::detectCores()-1 # number of cores that will be used for parallel computing
N.MC <- 500 # number of Monte Carlo iterations
stream <- unlist(RNGseq(ceiling(N.MC/5), seed = 100))[-seq(1, 1+(ceiling(N.MC/5)-1)*7, by =7)] # Choose a random stream for reproducibility
###################################################
## Writing a function for interpolation on covariance function (in Rcpp to speed up simulation)
###################################################
Rcpp::cppFunction(depends = "RcppArmadillo", code = '
arma::mat covIntrplCpp(const arma::mat& cov,
const arma::mat& B,
const arma::mat& B_fine) {
int p = B.n_rows;
int n_fine = B_fine.n_rows;
// Step 1: Construct Phi using Kronecker
arma::mat Phi = arma::kron(B, B);        // (p^2 x p^2)
arma::vec cov_vec = arma::vectorise(cov); // column-major vector
// Step 2: Solve for spline coefficients
arma::vec coef = arma::solve(Phi, cov_vec);
// Step 3: Construct Phi_fine using Kronecker
arma::mat Phi_fine = arma::kron(B_fine, B_fine);  // (n_fine^2 x p^2)
// Step 4: Interpolate on fine grid
arma::vec pred = Phi_fine * coef;
arma::mat pred_mat(pred.memptr(), n_fine, n_fine);
return pred_mat.t();  // transpose to match R matrix layout
}
')
cov.intrpl.rcpp <- function(cov, grid, n_fine) {
a <- min(grid)
b <- max(grid)
p <- length(grid)
# Spline basis matrix on original grid
B <- naturalSpline(grid, intercept = TRUE,
knots = grid[c(-1, -p)],
Boundary.knots = c(a, b))
# Fine grid
grid_fine <- seq(a, b, length.out = n_fine)
B_fine <- naturalSpline(grid_fine, intercept = TRUE,
knots = grid[c(-1, -p)],
Boundary.knots = c(a, b))
# Call Rcpp backend
cov.spline <- covIntrplCpp(cov, B, B_fine)
return(cov.spline)
}
###################################################
## Writing a function for Generating Training Data
###################################################
train.data <- function(MC,
p        = 11, # number of observable grid points (better to be odd, so that 0 is included. we need values at t=0 to estimate beta(t) in our functional data model.)
N        = 200, # number of units
att_fct  = "function(x) ifelse(x<=-4, 0, 3*(x+4)^2/(3+(x+4)^2))"){
set.seed(MC)
## observable grid points
grid <- ffscb::make_grid(p, rangevals = c(-10,10))
## Covariance
cov.smooth     <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid/10, cov.f.params = c(3/2,2))
cov.rough      <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid/10, cov.f.params = c(1/2,2))
## Error term
epsilon.smooth <- make_sample(mean.v = rep(0, p), cov.m = cov.smooth, N = N, dist = "rnorm")
epsilon.rough  <- make_sample(mean.v = rep(0, p), cov.m = cov.rough,  N = N, dist = "rnorm")
## Time fixed effect
phi_t <- meanf_shift((grid+10)/20,0)*2.5
## Individual fixed effect
lambda_i <- runif(N,-3,3)
## Treatment Assignment
pi  <- as.vector(exp(3*lambda_i)/(1+exp(3*lambda_i)))
D_i <- sapply(pi, function(x) rbinom(n=1,size=1,prob=x))
## Average treatment effect
att_fct <- eval(parse(text=att_fct))
## delta function
delta <- -att_fct(0)
# beta
beta_t <- att_fct(grid)+delta
## Responses
Y.smooth <- t(lambda_i + t(phi_t + beta_t * (outer(rep(1, p), D_i)) + epsilon.smooth))
Y.rough  <- t(lambda_i + t(phi_t + beta_t * (outer(rep(1, p), D_i)) + epsilon.rough))
Y.smooth <- Y.smooth[1:((p+1)/2),]
Y.rough <-  Y.rough[1:((p+1)/2),]
###########################
## Output
###########################
output <- list(Y.smooth=Y.smooth,
Y.rough=Y.rough,
D_i=D_i)
return(output)
}
p        = 11
t_A.pos  = 4
N        = 200
att_fct  = "function(x) ifelse(x<=-4, 0, 3*(x+4)^2/(3+(x+4)^2))"
n_spline = 101
train_data
train_data <-  train.data(MC=100, p=11, N=200, att_fct="function(x) ifelse(x<=-4, 0, 3*(x+4)^2/(3+(x+4)^2))")
## observable grid points
grid <- ffscb::make_grid(p, rangevals = c(-10,10))
## Covariance
cov.smooth     <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid/10, cov.f.params = c(3/2,2))
cov.rough      <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid/10, cov.f.params = c(1/2,2))
## Error term
epsilon.smooth <- make_sample(mean.v = rep(0, p), cov.m = cov.smooth, N = N, dist = "rnorm")
epsilon.rough  <- make_sample(mean.v = rep(0, p), cov.m = cov.rough,  N = N, dist = "rnorm")
## Time fixed effect
phi_t <- meanf_shift((grid+10)/20,0)*2.5
## Individual fixed effect
lambda_i <- runif(N,-3,3)
## Treatment Assignment
pi  <- as.vector(exp(3*lambda_i)/(1+exp(3*lambda_i)))
D_i <- sapply(pi, function(x) rbinom(n=1,size=1,prob=x))
## Average treatment effect
att_fct <- eval(parse(text=att_fct))
## delta function
delta <- -att_fct(0)
## Sequence of S
S_vec <- seq(0,10,by=0.1)
S=1
beta_t <- att_fct(grid)+delta
## Responses
Y.smooth.test <- t(lambda_i + t(phi_t + beta_t * (outer(rep(1, p), D_i)) + epsilon.smooth))
Y.rough.test  <- t(lambda_i + t(phi_t + beta_t * (outer(rep(1, p), D_i)) + epsilon.rough))
Y.smooth.test <- Y.smooth.test[ 1:((p+1)/2) ,]
Y.rough.test <- Y.rough.test[ 1:((p+1)/2) ,]
D_i.test <- D_i
## Extracting Training Data
Y.smooth.train <- train_data$Y.smooth
Y.rough.train  <- train_data$Y.rough
D_i.train <- train_data$D_i
###########################
## Estimation of beta using training data
###########################
## Two way transformation
Y.smooth.train.twfe <- t(t(Y.smooth.train - apply(Y.smooth.train, 1, mean) + mean(Y.smooth.train)) - apply(Y.smooth.train, 2, mean))
Y.rough.train.twfe  <- t(t(Y.rough.train  - apply(Y.rough.train, 1, mean)  + mean(Y.rough.train))  - apply(Y.rough.train, 2, mean))
D_tilde.train       <- D_i.train-mean(D_i.train)
gamma_hat.smooth.train    <- as.vector(solve(crossprod(D_tilde.train)) %*% t(D_tilde.train)  %*% t(Y.smooth.train.twfe))
gamma_hat.rough.train     <- as.vector(solve(crossprod(D_tilde.train)) %*% t(D_tilde.train)  %*% t(Y.rough.train.twfe))
beta_hat_fda.smooth.train <- gamma_hat.smooth.train -gamma_hat.smooth.train[(p+1)/2]
beta_hat_fda.rough.train  <- gamma_hat.rough.train -gamma_hat.rough.train[(p+1)/2]
###########################
## Estimation of beta using testing data
###########################
## Two way transformation
Y.smooth.test.twfe <- t(t(Y.smooth.test - apply(Y.smooth.test, 1, mean) + mean(Y.smooth.test)) - apply(Y.smooth.test, 2, mean))
Y.rough.test.twfe  <- t(t(Y.rough.test  - apply(Y.rough.test, 1, mean)  + mean(Y.rough.test))  - apply(Y.rough.test, 2, mean))
D_tilde.test       <- D_i.test-mean(D_i.test)
gamma_hat.smooth.test    <- as.vector(solve(crossprod(D_tilde.test)) %*% t(D_tilde.test)  %*% t(Y.smooth.test.twfe))
gamma_hat.rough.test     <- as.vector(solve(crossprod(D_tilde.test)) %*% t(D_tilde.test)  %*% t(Y.rough.test.twfe))
beta_hat_fda.smooth.test <- gamma_hat.smooth.test -gamma_hat.smooth.test[(p+1)/2]
beta_hat_fda.rough.test  <- gamma_hat.rough.test -gamma_hat.rough.test[(p+1)/2]
###########################
## Estimation of variance using training data
###########################
Y_fitted.smooth.train <- gamma_hat.smooth.train %o% D_tilde.train
Y_fitted.rough.train <- gamma_hat.rough.train %o% D_tilde.train
resid.smooth.train     <- Y_fitted.smooth.train - Y.smooth.train.twfe
resid.rough.train      <- Y_fitted.rough.train  - Y.rough.train.twfe
cov_gamma.smooth.train <- matrix(unlist(lapply(1:((p+1)/2), function(x) lapply(1:((p+1)/2), function(y) solve(1/N*crossprod(D_tilde.train)) %*% (1/(N-1)* t(D_tilde.train) %*% diag(x = resid.smooth.train[x,]*resid.smooth.train[y,], nrow = N) %*% D_tilde.train) %*% solve(1/N*crossprod(D_tilde.train)))))/N, ncol=((p+1)/2))
cov_gamma.rough.train  <- matrix(unlist(lapply(1:((p+1)/2), function(x) lapply(1:((p+1)/2), function(y) solve(1/N*crossprod(D_tilde.train)) %*% (1/(N-1)* t(D_tilde.train) %*% diag(x = resid.rough.train[x,]*resid.rough.train[y,], nrow = N) %*% D_tilde.train) %*% solve(1/N*crossprod(D_tilde.train)))))/N, ncol=((p+1)/2)  )
var_beta.smooth.train <- diag(cov_gamma.smooth.train)+cov_gamma.smooth.train[(p+1)/2,(p+1)/2]-2*cov_gamma.smooth.train[,(p+1)/2]
var_beta.rough.train <- diag(cov_gamma.rough.train)+cov_gamma.rough.train[(p+1)/2,(p+1)/2]-2*cov_gamma.rough.train[,(p+1)/2]
###########################
## Estimation of covariance using testing data
###########################
Y_fitted.smooth.test <- gamma_hat.smooth.test %o% D_tilde.test
Y_fitted.rough.test <- gamma_hat.rough.test %o% D_tilde.test
resid.smooth.test     <- Y_fitted.smooth.test - Y.smooth.test.twfe
resid.rough.test      <- Y_fitted.rough.test  - Y.rough.test.twfe
cov_gamma.smooth.test <- matrix(unlist(lapply(1:((p+1)/2), function(x) lapply(1:((p+1)/2), function(y) solve(1/N*crossprod(D_tilde.test)) %*% (1/(N-1)* t(D_tilde.test) %*% diag(x = resid.smooth.test[x,]*resid.smooth.test[y,], nrow = N) %*% D_tilde.test) %*% solve(1/N*crossprod(D_tilde.test)))))/N, ncol=((p+1)/2))
cov_gamma.rough.test  <- matrix(unlist(lapply(1:((p+1)/2), function(x) lapply(1:((p+1)/2), function(y) solve(1/N*crossprod(D_tilde.test)) %*% (1/(N-1)* t(D_tilde.test) %*% diag(x = resid.rough.test[x,]*resid.rough.test[y,], nrow = N) %*% D_tilde.test) %*% solve(1/N*crossprod(D_tilde.test)))))/N, ncol=((p+1)/2))
cov_gamma_alpha.smooth.test <- -cov_gamma.smooth.test[,(p+1)/2]
cov_gamma_alpha.rough.test  <- -cov_gamma.rough.test[,(p+1)/2]
se_alpha.smooth.test <- sqrt(cov_gamma.smooth.test[(p+1)/2,(p+1)/2])
se_alpha.rough.test  <- sqrt(cov_gamma.rough.test[(p+1)/2,(p+1)/2])
cov_beta_fda.smooth.test <- (sweep(cov_gamma.smooth.test*N+ cov_gamma_alpha.smooth.test*N,2,cov_gamma_alpha.smooth.test*N,FUN="+")+se_alpha.smooth.test^2*N )/N
cov_beta_fda.rough.test  <- (sweep(cov_gamma.rough.test*N+ cov_gamma_alpha.rough.test*N,2,cov_gamma_alpha.rough.test*N,FUN="+")+se_alpha.rough.test^2*N )/N
cov_beta_fda.smooth.test[(p+1)/2,] <- 0; cov_beta_fda.smooth.test[,(p+1)/2] <- 0
cov_beta_fda.rough.test[(p+1)/2,]  <- 0; cov_beta_fda.rough.test[,(p+1)/2]  <- 0
###########################
## Construction of splines for pre-ANTICIPATION period  (on n_spline-1 points so that 0 is not included; cov2tau_fun and confidence_band could not take 0 in their operations)
###########################
### extract data on pre-ANTICIPATION period only
beta_hat_fda.smooth.test <- beta_hat_fda.smooth.test[1: t_A.pos]
beta_hat_fda.rough.test <- beta_hat_fda.rough.test[1: t_A.pos]
cov_beta_fda.smooth.test <- cov_beta_fda.smooth.test[1: t_A.pos, 1: t_A.pos]
cov_beta_fda.rough.test <- cov_beta_fda.rough.test[1: t_A.pos, 1: t_A.pos]
#### natural spline on beta for pre-treatment period
beta_hat_fda.smooth.test.spline <- spline(beta_hat_fda.smooth.test, n=n_spline, method="natural")$y
beta_hat_fda.rough.test.spline  <- spline(beta_hat_fda.rough.test, n=n_spline, method="natural")$y
#### natural spline on covariance function for pre-treatment period
cov_beta_fda.smooth.test.spline <- cov.intrpl.rcpp(cov=cov_beta_fda.smooth.test, grid[1:t_A.pos], n_fine=n_spline)
cov_beta_fda.rough.test.spline  <- cov.intrpl.rcpp(cov=cov_beta_fda.rough.test, grid[1:t_A.pos], n_fine=n_spline)
###########################
## (Simultaneous) CBs for pre-ANTICIPATION period
###########################
hat_tau.smooth.test <- ffscb::cov2tau_fun(cov_mat=cov_beta_fda.smooth.test.spline)
hat_tau.rough.test  <- ffscb::cov2tau_fun(cov_mat=cov_beta_fda.rough.test.spline)
bands.smooth.test <- confidence_band(x=beta_hat_fda.smooth.test.spline, cov.x=cov_beta_fda.smooth.test.spline, tau=hat_tau.smooth.test, df=N-1, type=c("FFSCB.t", "naive.t"), conf.level=0.9, n_int=1)
bands.rough.test  <- confidence_band(x=beta_hat_fda.rough.test.spline,  cov.x=cov_beta_fda.rough.test.spline,  tau=hat_tau.rough.test, df=N-1, type=c("FFSCB.t", "naive.t"), conf.level=0.9, n_int=1)
bands.bonf.smooth.test <- cbind(beta_hat_fda.smooth.test.spline + qt(1-(0.1/n_spline)/2, df=N-1)*sqrt(diag(cov_beta_fda.smooth.test.spline)),beta_hat_fda.smooth.test.spline - qt(1-(0.1/n_spline)/2, df=N-1)*sqrt(diag(cov_beta_fda.smooth.test.spline)))
bands.bonf.rough.test  <- cbind(beta_hat_fda.rough.test.spline  + qt(1-(0.1/n_spline)/2, df=N-1)*sqrt(diag(cov_beta_fda.rough.test.spline)),beta_hat_fda.rough.test.spline  - qt(1-(0.1/n_spline)/2, df=N-1)*sqrt(diag(cov_beta_fda.rough.test.spline)))
###########################
## Re-evaluate the (Simultaneous) CBs on n_spline points
###########################
# band.func <- function(band) {
#
#   grid_old <- seq(-10, 10, length.out=n_spline-1)[1:((n_spline-1)/2)]      #[((n_spline+1)/2):(n_spline-1)]
#   grid_new <- seq(-10, 10, length.out=n_spline)[1:((n_spline+1)/2)]        #[((n_spline+3)/2):n_spline]
#
#   ref_time_ind <- tail(which(grid_old<=0), 1)+1
#   grid_band <- append(grid_old, 0, after = ref_time_ind)
#   value_band <- append(band, 0, after = ref_time_ind)
#
#   band_splinefun <- splinefun(x=grid_band, y=value_band, method="natural")
#   band_new <- band_splinefun(grid_new)
#   return(band_new)
#
# }
#
# bands.smooth.test      <- apply(bands.smooth.test, 2, band.func)
# bands.rough.test       <- apply(bands.rough.test, 2, band.func)
# bands.bonf.smooth.test <- apply(bands.bonf.smooth.test, 2, band.func)
# bands.bonf.rough.test  <- apply(bands.bonf.rough.test, 2, band.func)
###########################
## Coverage
###########################
att_fct  = "function(x) ifelse(x<=-4, 0, 3*(x+4)^2/(3+(x+4)^2))"
S=0
## observable grid points
grid <- ffscb::make_grid(p, rangevals = c(-10,10))
## Covariance
cov.smooth     <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid/10, cov.f.params = c(3/2,2))
cov.rough      <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid/10, cov.f.params = c(1/2,2))
## Error term
epsilon.smooth <- make_sample(mean.v = rep(0, p), cov.m = cov.smooth, N = N, dist = "rnorm")
epsilon.rough  <- make_sample(mean.v = rep(0, p), cov.m = cov.rough,  N = N, dist = "rnorm")
## Time fixed effect
phi_t <- meanf_shift((grid+10)/20,0)*2.5
## Individual fixed effect
lambda_i <- runif(N,-3,3)
## Treatment Assignment
pi  <- as.vector(exp(3*lambda_i)/(1+exp(3*lambda_i)))
D_i <- sapply(pi, function(x) rbinom(n=1,size=1,prob=x))
## Average treatment effect
att_fct <- eval(parse(text=att_fct))
## delta function
delta <- -att_fct(0)
## Sequence of S
S_vec <- seq(0,10,by=0.1)
S
beta_t <- att_fct(grid)+delta
## Responses
Y.smooth.test <- t(lambda_i + t(phi_t + beta_t * (outer(rep(1, p), D_i)) + epsilon.smooth))
Y.rough.test  <- t(lambda_i + t(phi_t + beta_t * (outer(rep(1, p), D_i)) + epsilon.rough))
Y.smooth.test <- Y.smooth.test[ 1:((p+1)/2) ,]
Y.rough.test <- Y.rough.test[ 1:((p+1)/2) ,]
D_i.test <- D_i
## Extracting Training Data
Y.smooth.train <- train_data$Y.smooth
Y.rough.train  <- train_data$Y.rough
D_i.train <- train_data$D_i
###########################
## Estimation of beta using training data
###########################
## Two way transformation
Y.smooth.train.twfe <- t(t(Y.smooth.train - apply(Y.smooth.train, 1, mean) + mean(Y.smooth.train)) - apply(Y.smooth.train, 2, mean))
Y.rough.train.twfe  <- t(t(Y.rough.train  - apply(Y.rough.train, 1, mean)  + mean(Y.rough.train))  - apply(Y.rough.train, 2, mean))
D_tilde.train       <- D_i.train-mean(D_i.train)
gamma_hat.smooth.train    <- as.vector(solve(crossprod(D_tilde.train)) %*% t(D_tilde.train)  %*% t(Y.smooth.train.twfe))
gamma_hat.rough.train     <- as.vector(solve(crossprod(D_tilde.train)) %*% t(D_tilde.train)  %*% t(Y.rough.train.twfe))
beta_hat_fda.smooth.train <- gamma_hat.smooth.train -gamma_hat.smooth.train[(p+1)/2]
beta_hat_fda.rough.train  <- gamma_hat.rough.train -gamma_hat.rough.train[(p+1)/2]
###########################
## Estimation of beta using testing data
###########################
## Two way transformation
Y.smooth.test.twfe <- t(t(Y.smooth.test - apply(Y.smooth.test, 1, mean) + mean(Y.smooth.test)) - apply(Y.smooth.test, 2, mean))
Y.rough.test.twfe  <- t(t(Y.rough.test  - apply(Y.rough.test, 1, mean)  + mean(Y.rough.test))  - apply(Y.rough.test, 2, mean))
D_tilde.test       <- D_i.test-mean(D_i.test)
gamma_hat.smooth.test    <- as.vector(solve(crossprod(D_tilde.test)) %*% t(D_tilde.test)  %*% t(Y.smooth.test.twfe))
gamma_hat.rough.test     <- as.vector(solve(crossprod(D_tilde.test)) %*% t(D_tilde.test)  %*% t(Y.rough.test.twfe))
beta_hat_fda.smooth.test <- gamma_hat.smooth.test -gamma_hat.smooth.test[(p+1)/2]
beta_hat_fda.rough.test  <- gamma_hat.rough.test -gamma_hat.rough.test[(p+1)/2]
###########################
## Estimation of variance using training data
###########################
Y_fitted.smooth.train <- gamma_hat.smooth.train %o% D_tilde.train
Y_fitted.rough.train <- gamma_hat.rough.train %o% D_tilde.train
resid.smooth.train     <- Y_fitted.smooth.train - Y.smooth.train.twfe
resid.rough.train      <- Y_fitted.rough.train  - Y.rough.train.twfe
cov_gamma.smooth.train <- matrix(unlist(lapply(1:((p+1)/2), function(x) lapply(1:((p+1)/2), function(y) solve(1/N*crossprod(D_tilde.train)) %*% (1/(N-1)* t(D_tilde.train) %*% diag(x = resid.smooth.train[x,]*resid.smooth.train[y,], nrow = N) %*% D_tilde.train) %*% solve(1/N*crossprod(D_tilde.train)))))/N, ncol=((p+1)/2))
cov_gamma.rough.train  <- matrix(unlist(lapply(1:((p+1)/2), function(x) lapply(1:((p+1)/2), function(y) solve(1/N*crossprod(D_tilde.train)) %*% (1/(N-1)* t(D_tilde.train) %*% diag(x = resid.rough.train[x,]*resid.rough.train[y,], nrow = N) %*% D_tilde.train) %*% solve(1/N*crossprod(D_tilde.train)))))/N, ncol=((p+1)/2)  )
var_beta.smooth.train <- diag(cov_gamma.smooth.train)+cov_gamma.smooth.train[(p+1)/2,(p+1)/2]-2*cov_gamma.smooth.train[,(p+1)/2]
var_beta.rough.train <- diag(cov_gamma.rough.train)+cov_gamma.rough.train[(p+1)/2,(p+1)/2]-2*cov_gamma.rough.train[,(p+1)/2]
###########################
## Estimation of covariance using testing data
###########################
Y_fitted.smooth.test <- gamma_hat.smooth.test %o% D_tilde.test
Y_fitted.rough.test <- gamma_hat.rough.test %o% D_tilde.test
resid.smooth.test     <- Y_fitted.smooth.test - Y.smooth.test.twfe
resid.rough.test      <- Y_fitted.rough.test  - Y.rough.test.twfe
cov_gamma.smooth.test <- matrix(unlist(lapply(1:((p+1)/2), function(x) lapply(1:((p+1)/2), function(y) solve(1/N*crossprod(D_tilde.test)) %*% (1/(N-1)* t(D_tilde.test) %*% diag(x = resid.smooth.test[x,]*resid.smooth.test[y,], nrow = N) %*% D_tilde.test) %*% solve(1/N*crossprod(D_tilde.test)))))/N, ncol=((p+1)/2))
cov_gamma.rough.test  <- matrix(unlist(lapply(1:((p+1)/2), function(x) lapply(1:((p+1)/2), function(y) solve(1/N*crossprod(D_tilde.test)) %*% (1/(N-1)* t(D_tilde.test) %*% diag(x = resid.rough.test[x,]*resid.rough.test[y,], nrow = N) %*% D_tilde.test) %*% solve(1/N*crossprod(D_tilde.test)))))/N, ncol=((p+1)/2))
cov_gamma_alpha.smooth.test <- -cov_gamma.smooth.test[,(p+1)/2]
cov_gamma_alpha.rough.test  <- -cov_gamma.rough.test[,(p+1)/2]
se_alpha.smooth.test <- sqrt(cov_gamma.smooth.test[(p+1)/2,(p+1)/2])
se_alpha.rough.test  <- sqrt(cov_gamma.rough.test[(p+1)/2,(p+1)/2])
cov_beta_fda.smooth.test <- (sweep(cov_gamma.smooth.test*N+ cov_gamma_alpha.smooth.test*N,2,cov_gamma_alpha.smooth.test*N,FUN="+")+se_alpha.smooth.test^2*N )/N
cov_beta_fda.rough.test  <- (sweep(cov_gamma.rough.test*N+ cov_gamma_alpha.rough.test*N,2,cov_gamma_alpha.rough.test*N,FUN="+")+se_alpha.rough.test^2*N )/N
cov_beta_fda.smooth.test[(p+1)/2,] <- 0; cov_beta_fda.smooth.test[,(p+1)/2] <- 0
cov_beta_fda.rough.test[(p+1)/2,]  <- 0; cov_beta_fda.rough.test[,(p+1)/2]  <- 0
###########################
## Construction of splines for pre-ANTICIPATION period  (on n_spline-1 points so that 0 is not included; cov2tau_fun and confidence_band could not take 0 in their operations)
###########################
### extract data on pre-ANTICIPATION period only
beta_hat_fda.smooth.test <- beta_hat_fda.smooth.test[1: t_A.pos]
beta_hat_fda.rough.test <- beta_hat_fda.rough.test[1: t_A.pos]
cov_beta_fda.smooth.test <- cov_beta_fda.smooth.test[1: t_A.pos, 1: t_A.pos]
cov_beta_fda.rough.test <- cov_beta_fda.rough.test[1: t_A.pos, 1: t_A.pos]
#### natural spline on beta for pre-treatment period
beta_hat_fda.smooth.test.spline <- spline(beta_hat_fda.smooth.test, n=n_spline, method="natural")$y
beta_hat_fda.rough.test.spline  <- spline(beta_hat_fda.rough.test, n=n_spline, method="natural")$y
#### natural spline on covariance function for pre-treatment period
cov_beta_fda.smooth.test.spline <- cov.intrpl.rcpp(cov=cov_beta_fda.smooth.test, grid[1:t_A.pos], n_fine=n_spline)
cov_beta_fda.rough.test.spline  <- cov.intrpl.rcpp(cov=cov_beta_fda.rough.test, grid[1:t_A.pos], n_fine=n_spline)
###########################
## (Simultaneous) CBs for pre-ANTICIPATION period
###########################
hat_tau.smooth.test <- ffscb::cov2tau_fun(cov_mat=cov_beta_fda.smooth.test.spline)
hat_tau.rough.test  <- ffscb::cov2tau_fun(cov_mat=cov_beta_fda.rough.test.spline)
bands.smooth.test <- confidence_band(x=beta_hat_fda.smooth.test.spline, cov.x=cov_beta_fda.smooth.test.spline, tau=hat_tau.smooth.test, df=N-1, type=c("FFSCB.t", "naive.t"), conf.level=0.9, n_int=1)
bands.rough.test  <- confidence_band(x=beta_hat_fda.rough.test.spline,  cov.x=cov_beta_fda.rough.test.spline,  tau=hat_tau.rough.test, df=N-1, type=c("FFSCB.t", "naive.t"), conf.level=0.9, n_int=1)
bands.bonf.smooth.test <- cbind(beta_hat_fda.smooth.test.spline + qt(1-(0.1/n_spline)/2, df=N-1)*sqrt(diag(cov_beta_fda.smooth.test.spline)),beta_hat_fda.smooth.test.spline - qt(1-(0.1/n_spline)/2, df=N-1)*sqrt(diag(cov_beta_fda.smooth.test.spline)))
bands.bonf.rough.test  <- cbind(beta_hat_fda.rough.test.spline  + qt(1-(0.1/n_spline)/2, df=N-1)*sqrt(diag(cov_beta_fda.rough.test.spline)),beta_hat_fda.rough.test.spline  - qt(1-(0.1/n_spline)/2, df=N-1)*sqrt(diag(cov_beta_fda.rough.test.spline)))
###########################
## Re-evaluate the (Simultaneous) CBs on n_spline points
###########################
# band.func <- function(band) {
#
#   grid_old <- seq(-10, 10, length.out=n_spline-1)[1:((n_spline-1)/2)]      #[((n_spline+1)/2):(n_spline-1)]
#   grid_new <- seq(-10, 10, length.out=n_spline)[1:((n_spline+1)/2)]        #[((n_spline+3)/2):n_spline]
#
#   ref_time_ind <- tail(which(grid_old<=0), 1)+1
#   grid_band <- append(grid_old, 0, after = ref_time_ind)
#   value_band <- append(band, 0, after = ref_time_ind)
#
#   band_splinefun <- splinefun(x=grid_band, y=value_band, method="natural")
#   band_new <- band_splinefun(grid_new)
#   return(band_new)
#
# }
#
# bands.smooth.test      <- apply(bands.smooth.test, 2, band.func)
# bands.rough.test       <- apply(bands.rough.test, 2, band.func)
# bands.bonf.smooth.test <- apply(bands.bonf.smooth.test, 2, band.func)
# bands.bonf.rough.test  <- apply(bands.bonf.rough.test, 2, band.func)
###########################
## Coverage
###########################
# reference line
ref.line.smooth.train <- beta_hat_fda.smooth.train[t_A.pos]
ref.line.rough.train <- beta_hat_fda.rough.train[t_A.pos]
ref.line.smooth.train
View(bands.smooth.test)
all(c(0,1,1))
all(c(T,F,F))
library(devtools)
document()
data(Gdata)
fdid_scb_est <- fdid_scb(beta=Gdata$beta, cov=Gdata$cov, t0=Gdata$t0)
par(family="Times")
pdf("plot_scb_ta.pdf", width = 8, height = 6)
plot(fdid_scb_est, ta.ts = -9, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
dev.off()
library(pdftools)
pdf_convert("plot_scb_ta.pdf", format = "png", filenames = "plot_scb_ta.png", dpi = 300)
library(pkgdown)
build_site()
library(pkgdown)
build_site()
library(pkgdown)
build_site()
library(fdid)
data(Gdata)
fdid_scb_est <- fdid_scb(beta=Gdata$beta, cov=Gdata$cov, t0=Gdata$t0)
plot(fdid_scb_est, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-8, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-8, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-9, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
library(fdid)
data(Gdata)
fdid_scb_est <- fdid_scb(beta=Gdata$beta, cov=Gdata$cov, t0=Gdata$t0)
plot(fdid_scb_est, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-8, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est,  ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
library(fdid)
data(Gdata)
fdid_scb_est <- fdid_scb(beta=Gdata$beta, cov=Gdata$cov, t0=Gdata$t0)
Gdata$t0
plot(fdid_scb_est, ta.ts=-8, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
library(pkgdown)
build_site()
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
cat("The reference time is ", LWdata$t0, ". If not NULL, the input 'ta.t0' in function 'plot' should be smaller than this value.", sep="")
## simultaneous inference
par(cex.axis = 1.4, cex.lab = 1.4, cex.main = 1.4)
plot(fdid_scb_est, scale.legend=1.4)
## adding a label for Y-axis
library(devtools)
document()
install()
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
cat("The reference time is ", LWdata$t0, ". If not NULL, the input 'ta.ts' in function 'plot' should be smaller than this value.", sep="")
## simultaneous inference
par(cex.axis = 1.4, cex.lab = 1.4, cex.main = 1.4)
plot(fdid_scb_est, scale.legend=1.4)
## adding a label for Y-axis
title(ylab="Effects of Duty-to-Bargain Laws")
## honest inference under treatment anticipation
plot(fdid_scb_est, ta.ts=-3, scale.legend=1.4)
library(pkgdown)
build_site()
library(fdid)
data(Gdata)
fdid_scb_est <- fdid_scb(beta=Gdata$beta, cov=Gdata$cov, t0=Gdata$t0)
plot(fdid_scb_est, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, ta.ts=-9, ta.s=2.6, pos.legend="bottom", scale.legend=1.4)
plot(fdid_scb_est, frm.mbar=1, pos.legend="bottom", scale.legend=1.4)
