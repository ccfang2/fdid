while (t0 %in% timeVec_spline) {len_spline <- len_spline+1; timeVec_spline <- seq(min(timeVec), max(timeVec), length.out=len_spline) }
# betahat_spline    <- spline(x=timeVec, y=betahat, n=len_spline, method="natural")$y
# betahat_splinefun <- splinefun(x=timeVec, y=betahat, method="natural")
# covhat_spline     <- cov_spline(cov=covhat, grid=timeVec, n_intrpl=len_spline)
# if (any(is.na(covhat))) {
#   covhat_spline <- apply(covhat, 2, function(col) { obs_idx <- !is.na(col); obs_event_t <- timeVec[obs_idx]; obs_col <- col[obs_idx]; spline_fit <- spline(obs_event_t, obs_col, xout = timeVec_spline, method = "natural")$y; spline_fit[timeVec_spline > max(obs_event_t) | timeVec_spline < min(obs_event_t)] <- NA; return(spline_fit)})
#   covhat_spline <- apply(covhat_spline, 1, function(row) { obs_idx <- !is.na(row); obs_event_t <- timeVec[obs_idx]; obs_row <- row[obs_idx]; spline_fit <- spline(obs_event_t, obs_row, xout = timeVec_spline, method = "natural")$y; spline_fit[timeVec_spline > max(obs_event_t) | timeVec_spline < min(obs_event_t)] <- NA; return(spline_fit)})
# } else{
#   covhat_spline <- apply(covhat, 2, function(col) spline(x=timeVec, y=col, n=len_spline, method="natural")$y)
#   covhat_spline <- apply(covhat_spline, 1, function(row) spline(x=timeVec, y=row, n=len_spline, method="natural")$y)
# }
# compute tau function for pre-treatment periods
timeVec_pre     <- timeVec[which(timeVec<=t0)]
betahat_pre     <- betahat[which(timeVec<=t0)]
covhat_pre      <- covhat[which(timeVec<=t0), which(timeVec<=t0)]
diag_covhat_pre <- diag(covhat_pre)
len_spline_pre  <- sum(timeVec_spline<=t0)
betahat_spline_pre    <- spline(x=timeVec_pre, y=betahat_pre, n=len_spline_pre, method="natural")$y
betahat_splinefun_pre <- splinefun(x=timeVec_pre, y=betahat_pre, method="natural")
covhat_spline_pre     <- cov_spline(cov=covhat_pre, grid=timeVec_pre, n_intrpl=len_spline_pre)
diag_covhat_spline_pre <- diag(covhat_spline_pre)
# hat.tau_pre            <- ffscb::cov2tau_fun(covhat_spline_pre)
# compute simultaneous confidence band for pre-treatment periods
if(is.null(df)){
scb_pre <- cbind(betahat_spline_pre, betahat_spline_pre + qnorm(1-scb.pre.alpha)*sqrt(diag_covhat_spline_pre),  betahat_spline_pre - qnorm(1-scb.pre.alpha)*sqrt(diag_covhat_spline_pre))
# if (any(is.na(covhat_spline_pre))) {
#   scb_pre <- ffscb::confidence_band_fragm(x=betahat_spline_pre, diag.cov.x=diag_covhat_spline_pre, tau=hat.tau_pre, type = "FFSCB.z", conf.level=1-2*scb.pre.alpha, n_int=1)
# } else {
#   scb_pre <- ffscb::confidence_band(x=betahat_spline_pre, cov.x=covhat_spline_pre, tau=hat.tau_pre, type="FFSCB.z", conf.level=1-2*scb.pre.alpha, n_int=1)
# }
} else{
scb_pre <- cbind(betahat_spline_pre, betahat_spline_pre + qt(1-scb.pre.alpha, df=df)*sqrt(diag_covhat_spline_pre),  betahat_spline_pre - qt(1-scb.pre.alpha, df=df)*sqrt(diag_covhat_spline_pre))
# if (any(is.na(covhat_spline_pre))) {
#   scb_pre <- ffscb::confidence_band_fragm(x=betahat_spline_pre, diag.cov.x=diag_covhat_spline_pre, tau=hat.tau_pre, df=df, type = "FFSCB.t", conf.level=1-2*scb.pre.alpha, n_int=1)
# } else {
#   scb_pre <- ffscb::confidence_band(x=betahat_spline_pre, cov.x=covhat_spline_pre, tau=hat.tau_pre,  df=df, type="FFSCB.t", conf.level=1-2*scb.pre.alpha, n_int=1)
# }
}
# if(is.null(df)){
#   if (any(is.na(covhat_spline_pre))) {
#     scb_pre <- ffscb::confidence_band_fragm(x=betahat_spline_pre, diag.cov.x=diag_covhat_spline_pre, tau=hat.tau_pre, type = "FFSCB.z", conf.level=1-2*scb.pre.alpha, n_int=1)
#   } else {
#     scb_pre <- ffscb::confidence_band(x=betahat_spline_pre, cov.x=covhat_spline_pre, tau=hat.tau_pre, type="FFSCB.z", conf.level=1-2*scb.pre.alpha, n_int=1)
#   }
# } else{
#   if (any(is.na(covhat_spline_pre))) {
#     scb_pre <- ffscb::confidence_band_fragm(x=betahat_spline_pre, diag.cov.x=diag_covhat_spline_pre, tau=hat.tau_pre, df=df, type = "FFSCB.t", conf.level=1-2*scb.pre.alpha, n_int=1)
#   } else {
#     scb_pre <- ffscb::confidence_band(x=betahat_spline_pre, cov.x=covhat_spline_pre, tau=hat.tau_pre,  df=df, type="FFSCB.t", conf.level=1-2*scb.pre.alpha, n_int=1)
#   }
# }
# compute tau function for post-treatment periods
timeVec_post     <- timeVec[which(timeVec>t0)]
betahat_post     <- betahat[which(timeVec>t0)]
covhat_post      <- covhat[which(timeVec>t0), which(timeVec>t0)]
diag_covhat_post <- diag(covhat_post)
len_spline_post  <- sum(timeVec_spline>t0)
betahat_spline_post    <- spline(x=timeVec_post, y=betahat_post, n=len_spline_post, method="natural")$y
betahat_splinefun_post <- splinefun(x=timeVec_post, y=betahat_post, method="natural")
covhat_spline_post     <- cov_spline(cov=covhat_post, grid=timeVec_post, n_intrpl=len_spline_post)
diag_covhat_spline_post <- diag(covhat_spline_post)
# betahat_spline_post     <- betahat_spline[which(timeVec_spline>=t0)]
# covhat_spline_post      <- covhat_spline[which(timeVec_spline>=t0), which(timeVec_spline>=t0)]
# diag_covhat_spline_post <- diag(covhat_spline_post)
hat.tau_post            <- ffscb::cov2tau_fun(covhat_spline_post)
# compute simultaneous confidence band for post-treatment periods
if(is.null(df)){
# if (any(is.na(covhat_spline_post))) {
#   scb_post <- ffscb::confidence_band_fragm(x=betahat_spline_post, diag.cov.x=diag_covhat_spline_post, tau=hat.tau_post, type = "FFSCB.z", conf.level=1-scb.post.alpha, n_int=1)
# } else {
scb_post <- ffscb::confidence_band(x=betahat_spline_post, cov.x=covhat_spline_post, tau=hat.tau_post, type="FFSCB.z", conf.level=1-scb.post.alpha, n_int=1)
# }
} else{
# if (any(is.na(covhat_spline_post))) {
#   scb_post <- ffscb::confidence_band_fragm(x=betahat_spline_post, diag.cov.x=diag_covhat_spline_post, tau=hat.tau_post, df=df, type = "FFSCB.t", conf.level=1-scb.post.alpha, n_int=1)
# } else {
scb_post <- ffscb::confidence_band(x=betahat_spline_post, cov.x=covhat_spline_post, tau=hat.tau_post,  df=df, type="FFSCB.t", conf.level=1-scb.post.alpha, n_int=1)
# }
}
idx_pos          <- which(timeVec_spline>=t0)[1]
scb              <- rbind(scb_pre, 0, scb_post)
x                <- c(timeVec_spline[1:(idx_pos-1)],t0,timeVec_spline[idx_pos:len_spline])
scb_ub_splinefun <- splinefun(x=x, y=scb[,(ncol(scb)-1)], method="natural")
scb_lb_splinefun <- splinefun(x=x, y=scb[,ncol(scb)], method="natural")
curve(scb_lb_splinefun,-15,15)
curve(scb_ub_splinefun,-15,15,add=TRUE)
curve(betahat_splinefun,-15,15,add=T, col="red")
ci_upper
points(seq(-15,15,len=31), ci_upper)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
object <- fdid_scb_est
ta.ts=NULL
ta.s=NULL
frm.mbar=NULL
ftr.m=NULL
frmtr.mbar=NULL
ref.band.pre=TRUE
note.pre=TRUE
note.post=TRUE
ci.pre=TRUE
ci.post=TRUE
pos.legend="top"
scale.legend=1
# check conditions
if (!base::inherits(object,"fdid_scb")) stop("The input 'object' should be an output of function 'fdid_scb'.")
if (!is.null(ta.ts) && (!is.numeric(ta.ts) || length(ta.ts) != 1)) stop("The input 'ta.ts' should be either NULL or a numeric scalar.")
if (!is.null(ta.ts) && !(ta.ts %in% object$scb$event_t[which(object$scb$event_t<=object$data$t0)])) stop("If not NULL, the input 'ta.ts' should be among the pre-treatment event time in 'object'.")
if (!is.null(ta.ts) && ta.ts == object$scb$event_t[1] && !all(sapply(list(frm.mbar, ftr.m, frmtr.mbar), is.null))) stop("If 'ta.ts' is defined to be the first event time, 'frm.mbar', 'ftr.m' and 'frmtr.mbar' must be NULL, because there is no available data for computing pre-trend differences.")
if (!is.null(ta.s) && (!is.numeric(ta.s) || length(ta.s) != 1 || ta.s < 0)) stop("The input 'ta.s' should be either NULL or a numeric non-negative scalar.")
if (!is.null(frm.mbar) && (!is.numeric(frm.mbar) || length(frm.mbar) != 1 || frm.mbar < 0)) stop("The input 'frm.mbar' should be either NULL or a numeric non-negative scalar.")
if (!is.null(ftr.m) && (!is.numeric(ftr.m) || length(ftr.m) != 1 || ftr.m < 0)) stop("The input 'ftr.m' should be either NULL or a numeric non-negative scalar.")
if (!is.null(frmtr.mbar) && (!is.numeric(frmtr.mbar) || length(frmtr.mbar) != 1 || frmtr.mbar < 0)) stop("The input 'frmtr.mbar' should be either NULL or a numeric non-negative scalar.")
if (!is.null(frm.mbar) && !is.null(ftr.m) && !is.null(frmtr.mbar)) stop("Exactly one of inputs 'frm.mbar', 'ftr.m' and 'frmtr.mbar' can have a value, or all three are NULL.")
if (!is.logical(ref.band.pre)) stop("The input 'ref.band.pre' should be logical.")
if (!is.logical(note.pre)) stop("The input 'note.pre' should be logical.")
if (!is.logical(note.post)) stop("The input 'note.post' should be logical.")
if (!is.logical(ci)) stop("The input 'ci' should be logical.")
if (!base::inherits(object,"fdid_scb")) stop("The input 'object' should be an output of function 'fdid_scb'.")
if (!is.null(ta.ts) && (!is.numeric(ta.ts) || length(ta.ts) != 1)) stop("The input 'ta.ts' should be either NULL or a numeric scalar.")
if (!is.null(ta.ts) && !(ta.ts %in% object$scb$event_t[which(object$scb$event_t<=object$data$t0)])) stop("If not NULL, the input 'ta.ts' should be among the pre-treatment event time in 'object'.")
if (!is.null(ta.ts) && ta.ts == object$scb$event_t[1] && !all(sapply(list(frm.mbar, ftr.m, frmtr.mbar), is.null))) stop("If 'ta.ts' is defined to be the first event time, 'frm.mbar', 'ftr.m' and 'frmtr.mbar' must be NULL, because there is no available data for computing pre-trend differences.")
if (!is.null(ta.s) && (!is.numeric(ta.s) || length(ta.s) != 1 || ta.s < 0)) stop("The input 'ta.s' should be either NULL or a numeric non-negative scalar.")
if (!is.null(frm.mbar) && (!is.numeric(frm.mbar) || length(frm.mbar) != 1 || frm.mbar < 0)) stop("The input 'frm.mbar' should be either NULL or a numeric non-negative scalar.")
if (!is.null(ftr.m) && (!is.numeric(ftr.m) || length(ftr.m) != 1 || ftr.m < 0)) stop("The input 'ftr.m' should be either NULL or a numeric non-negative scalar.")
if (!is.null(frmtr.mbar) && (!is.numeric(frmtr.mbar) || length(frmtr.mbar) != 1 || frmtr.mbar < 0)) stop("The input 'frmtr.mbar' should be either NULL or a numeric non-negative scalar.")
if (!is.null(frm.mbar) && !is.null(ftr.m) && !is.null(frmtr.mbar)) stop("Exactly one of inputs 'frm.mbar', 'ftr.m' and 'frmtr.mbar' can have a value, or all three are NULL.")
if (!is.logical(ref.band.pre)) stop("The input 'ref.band.pre' should be logical.")
if (!is.logical(note.pre)) stop("The input 'note.pre' should be logical.")
if (!is.logical(note.post)) stop("The input 'note.post' should be logical.")
if (!is.logical(ci.pre)) stop("The input 'ci.pre' should be logical.")
if (!is.logical(ci.post)) stop("The input 'ci.post' should be logical.")
if (!is.null(pos.legend) && !pos.legend %in% c("top", "bottom")) stop("The input 'pos.legend' must be 'top', 'bottom', or NULL.")
if (!is.numeric(scale.legend) || length(scale.legend) != 1 || scale.legend <= 0 || !is.finite(scale.legend)) stop("The input 'scale.legend' must be a positive number.")
# extract data from object
betahat <- object$data$beta[,1]
covhat  <- object$data$cov
timeVec <- object$data$beta[,2]
betahat_splinefun <- object$scb$betahat
scb_ub_splinefun  <- object$scb$scb_ub
scb_lb_splinefun  <- object$scb$scb_lb
ci_upper <- object$ci[,"ci_upper"]
ci_lower <- object$ci[,"ci_lower"]
start                     <- min(object$data$beta[,2])
end                       <- max(object$data$beta[,2])
t0                        <- object$data$t0
ci.alpha                  <- object$data$ci.alpha
scb.pre.alpha             <- object$data$scb.pre.alpha
scb.post.alpha            <- object$data$scb.post.alpha
is.null(ta.ts)
if (is.null(ta.ts)) ta.ts <- t0
ta.ts==t0 & is.null(frm.mbar) & is.null(ftr.m) & is.null(frmtr.mbar)
# find the time spans of statistical significance
n.int <- 200
roots <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun      <- function(x) scb_ub_splinefun(x)*scb_lb_splinefun(x)
interval <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root     <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots[i] <- if(inherits(root, "try-error")) {NA} else root
}
#roots <- roots[!is.na(roots)]
roots <- sort(unique(roots[!is.na(roots)]))
roots_vec    <- sort(unique(c(start,roots,end)))
stat_sig_vec <- rep(NA, length(roots_vec)-1)
for (i in 1:(length(roots_vec)-1)) {
test_point      <- (roots_vec[i]+roots_vec[i+1])/2
scb_ub_sign     <- sign(scb_ub_splinefun( test_point))
scb_lb_sign     <- sign(scb_lb_splinefun( test_point))
stat_sig_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
x_vals  <- seq(start, end, length.out = 5*length(timeVec))
y_range <- range(c(betahat_splinefun(x_vals), scb_ub_splinefun(x_vals), scb_lb_splinefun(x_vals)), na.rm=TRUE)
y_range <- c(y_range[1] - diff(y_range)*0.08, y_range[2] + diff(y_range)*0.08)
plot(timeVec, betahat,  type = "p", ylim =y_range, xlab = "Event Time", ylab = "", pch = 16, col = "blue")
if(isTRUE(ci.pre)) arrows(timeVec[which(timeVec<=t0)], ci_lower[which(timeVec<=t0)], timeVec[which(timeVec<=t0)], ci_upper[which(timeVec<=t0)], angle = 90, code = 3, length = 0.025, col = "blue4")
if(isTRUE(ci.post)) arrows(timeVec[which(timeVec>t0)], ci_lower[which(timeVec>t0)], timeVec[which(timeVec>t0)], ci_upper[which(timeVec>t0)], angle = 90, code = 3, length = 0.025, col = "blue4")
#grid()
curve(betahat_splinefun, add=TRUE, lty=1)
curve(scb_ub_splinefun, add=TRUE, lty=1)
curve(scb_lb_splinefun, add=TRUE, lty=1)
if(!isTRUE(ref.band.pre)) {
segments(x0=t0, y0=0, x1=end, y1=0, lty=3, lwd=4, col="red")
roots_vec_temp <- sort(unique(c(roots_vec, timeVec[which(timeVec==t0)-1], timeVec[which(timeVec==t0)+1])))
intervals <- data.frame(
left  = head(roots_vec_temp, -1),
right = tail(roots_vec_temp, -1)
)
stat_sig_vec_temp <- rep(NA, nrow(intervals))
for (i in 1:nrow(intervals)) {
l <- intervals$left[i]
r <- intervals$right[i]
if (l >= timeVec[which(timeVec==t0)-1] && r <= timeVec[which(timeVec==t0)+1]) {
stat_sig_vec_temp[i] <- 0
} else {
idx <- which(roots_vec <= l)[length(which(roots_vec  <= l))]
stat_sig_vec_temp[i] <- stat_sig_vec[idx]
}
}
stat_sig_vec <- stat_sig_vec_temp
roots_vec    <- roots_vec_temp
# if(!(t0 %in% roots_vec)) {
#   roots_vec <- sort(c(roots_vec, t0))
#   stat_sig_vec <- append(stat_sig_vec, stat_sig_vec[which(roots_vec==t0)-1], after=which(roots_vec==t0)-1-1)
# }
for (i in 1:(length(roots_vec)-1)) {
if (stat_sig_vec[i]==1 & roots_vec[i]>=t0 ) {
rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA) #alpha=0.7
} else {
if (stat_sig_vec[i]==-1 & roots_vec[i]>=t0) {
rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA)
}
}
}
} else {
segments(x0=start, y0=0, x1=end, y1=0, lty=3, lwd=4, col="red")
roots_vec_temp <- sort(unique(c(roots_vec, timeVec[which(timeVec==t0)-1], timeVec[which(timeVec==t0)+1])))
intervals <- data.frame(
left  = head(roots_vec_temp, -1),
right = tail(roots_vec_temp, -1)
)
stat_sig_vec_temp <- rep(NA, nrow(intervals))
for (i in 1:nrow(intervals)) {
l <- intervals$left[i]
r <- intervals$right[i]
if (l >= timeVec[which(timeVec==t0)-1] && r <= timeVec[which(timeVec==t0)+1]) {
stat_sig_vec_temp[i] <- 0
} else {
idx <- which(roots_vec <= l)[length(which(roots_vec  <= l))]
stat_sig_vec_temp[i] <- stat_sig_vec[idx]
}
}
stat_sig_vec <- stat_sig_vec_temp
roots_vec    <- roots_vec_temp
for (i in 1:(length(roots_vec)-1)) {
if (stat_sig_vec[i]==1) {
rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA) #alpha=0.7
} else {
if (stat_sig_vec[i]==-1) {
rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA)
}
}
}
}
roots_vec
!isTRUE(ref.band.pre)
ta.ts==t0 & is.null(frm.mbar) & is.null(ftr.m) & is.null(frmtr.mbar)
# find the time spans of statistical significance
n.int <- 200
roots <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun      <- function(x) scb_ub_splinefun(x)*scb_lb_splinefun(x)
interval <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root     <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots[i] <- if(inherits(root, "try-error")) {NA} else root
}
#roots <- roots[!is.na(roots)]
roots <- sort(unique(roots[!is.na(roots)]))
roots_vec    <- sort(unique(c(start,roots,end)))
stat_sig_vec <- rep(NA, length(roots_vec)-1)
for (i in 1:(length(roots_vec)-1)) {
test_point      <- (roots_vec[i]+roots_vec[i+1])/2
scb_ub_sign     <- sign(scb_ub_splinefun( test_point))
scb_lb_sign     <- sign(scb_lb_splinefun( test_point))
stat_sig_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
x_vals  <- seq(start, end, length.out = 5*length(timeVec))
y_range <- range(c(betahat_splinefun(x_vals), scb_ub_splinefun(x_vals), scb_lb_splinefun(x_vals)), na.rm=TRUE)
y_range <- c(y_range[1] - diff(y_range)*0.08, y_range[2] + diff(y_range)*0.08)
plot(timeVec, betahat,  type = "p", ylim =y_range, xlab = "Event Time", ylab = "", pch = 16, col = "blue")
if(isTRUE(ci.pre)) arrows(timeVec[which(timeVec<=t0)], ci_lower[which(timeVec<=t0)], timeVec[which(timeVec<=t0)], ci_upper[which(timeVec<=t0)], angle = 90, code = 3, length = 0.025, col = "blue4")
if(isTRUE(ci.post)) arrows(timeVec[which(timeVec>t0)], ci_lower[which(timeVec>t0)], timeVec[which(timeVec>t0)], ci_upper[which(timeVec>t0)], angle = 90, code = 3, length = 0.025, col = "blue4")
curve(betahat_splinefun, add=TRUE, lty=1)
curve(scb_ub_splinefun, add=TRUE, lty=1)
curve(scb_lb_splinefun, add=TRUE, lty=1)
!isTRUE(ref.band.pre)
segments(x0=start, y0=0, x1=end, y1=0, lty=3, lwd=4, col="red")
roots_vec_temp <- sort(unique(c(roots_vec, timeVec[which(timeVec==t0)-1], timeVec[which(timeVec==t0)+1])))
intervals <- data.frame(
left  = head(roots_vec_temp, -1),
right = tail(roots_vec_temp, -1)
)
stat_sig_vec_temp <- rep(NA, nrow(intervals))
for (i in 1:nrow(intervals)) {
l <- intervals$left[i]
r <- intervals$right[i]
if (l >= timeVec[which(timeVec==t0)-1] && r <= timeVec[which(timeVec==t0)+1]) {
stat_sig_vec_temp[i] <- 0
} else {
idx <- which(roots_vec <= l)[length(which(roots_vec  <= l))]
stat_sig_vec_temp[i] <- stat_sig_vec[idx]
}
}
stat_sig_vec <- stat_sig_vec_temp
roots_vec    <- roots_vec_temp
stat_sig_vec
roots_vec
library(fdid)
data(LWdata)
object=NULL
beta=LWdata$beta
cov=LWdata$cov
t0=LWdata$t0
df=NULL
ci.alpha=0.05
scb.pre.alpha=0.05
scb.post.alpha=0.05
if (!is.null(object) && !base::inherits(object,"fdid")) stop("The input 'object' should be either NULL or an output of function 'fdid'.")
if (!is.null(object)) warning("The input 'object' is provided, so 'beta', 'cov' and 't0' are ignored.")
if (!is.null(beta) && !is.matrix(beta)) stop("The input 'beta' should be either NULL or a numeric matrix.")
if (is.null(beta) && is.null(object)) stop("If any of 'beta', 'cov' and 't0' is NULL, 'object' must be provided.")
if (is.matrix(beta) && !is.numeric(beta)) stop("If 'beta' is not NULL, it should be a numeric matrix.")
if (is.matrix(beta) && any(is.na(beta))) stop("The input 'beta' should contain no missing values.")
if (!is.null(cov) && !is.matrix(cov)) stop("The input 'cov' should be eitherNULL or a matrix.")
if (is.null(cov) && is.null(object)) stop("If any of 'beta', 'cov' and 't0' is NULL, 'object' must be provided.")
if (!is.null(t0) && (!is.numeric(t0) || length(t0) != 1)) stop("The input 't0' should be either NULL or a numeric scalar.")
if (!is.null(df) && (!is.numeric(df) || length(df) != 1 || df <= 0)) stop("The input 'df' should be either NULL or a positive integer scalar.")
#
is.null(object)
# check further conditions
if (!(t0 %in% beta[,2])) stop("t0 should be in the time vector.")
if (beta[,1][which(beta[,2]==t0)]!=0) stop("beta at t0 should be normalized to 0.")
if (any(cov[which(beta[,2]==t0),]!=0) && any(covhat[,which(timeVec==t0)]!=0)) stop("Rows and columns of cov at t0 should all be normalized to 0.")
#beta[,2]       <- beta[,2]-t0
t_order        <- order(beta[,2])
beta           <- beta[t_order,]
colnames(beta) <- c(colnames(beta)[1], "event_t")
cov            <- cov[t_order, t_order]
colnames(cov)  <- rownames(cov) <- beta[,"event_t"]
betahat        <- beta[,1]
covhat         <- cov
timeVec        <- beta[,2]
t0             <- t0
df             <- df
if (is.null(df)) {
ci_upper <- betahat+qnorm(p=1-ci.alpha/2)*sqrt(diag(covhat))
ci_lower <- betahat-qnorm(p=1-ci.alpha/2)*sqrt(diag(covhat))
} else {
ci_upper <- betahat+qt(p=1-ci.alpha/2,df=df)*sqrt(diag(covhat))
ci_lower <- betahat-qt(p=1-ci.alpha/2,df=df)*sqrt(diag(covhat))
}
len_t      <- length(betahat)
len_spline <- 5*len_t
timeVec_spline <- seq(min(timeVec), max(timeVec), length.out=len_spline)
while (t0 %in% timeVec_spline) {len_spline <- len_spline+1; timeVec_spline <- seq(min(timeVec), max(timeVec), length.out=len_spline) }
# betahat_spline    <- spline(x=timeVec, y=betahat, n=len_spline, method="natural")$y
# betahat
timeVec_pre     <- timeVec[which(timeVec<=t0)]
betahat_pre     <- betahat[which(timeVec<=t0)]
covhat_pre      <- covhat[which(timeVec<=t0), which(timeVec<=t0)]
diag_covhat_pre <- diag(covhat_pre)
len_spline_pre  <- sum(timeVec_spline<=t0)
betahat_spline_pre    <- spline(x=timeVec_pre, y=betahat_pre, n=len_spline_pre, method="natural")$y
betahat_splinefun_pre <- splinefun(x=timeVec_pre, y=betahat_pre, method="natural")
covhat_spline_pre     <- cov_spline(cov=covhat_pre, grid=timeVec_pre, n_intrpl=len_spline_pre)
diag_covhat_spline_pre <- diag(covhat_spline_pre)
# hat.tau_pre            <- ffscb::cov2tau_fun(covhat_spline_pre)
B <- 300
T_boot <- numeric(B)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
betahat_spline_pre_b <- spline(betahat_pre_b, n=len_spline_pre, method="natural")$y
t_b <- (betahat_spline_pre_b - betahat_spline_pre)[-len_spline_pre] / sqrt(diag_covhat_spline_pre)[-len_spline_pre]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
scb_pre <- cbind(betahat_spline_pre, betahat_spline_pre+c_alpha*sqrt(diag_covhat_spline_pre), betahat_spline_pre-c_alpha*sqrt(diag_covhat_spline_pre))
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
t_b <- (betahat_pre_b - betahat_pre)[-length(betahat_pre)] / sqrt(diag(covhat_pre))[-length(betahat_pre)]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
scb_pre2  <- cbind(betahat_spline_pre, betahat_spline_pre+c_alpha*sqrt(diag_covhat_spline_pre), betahat_spline_pre-c_alpha*sqrt(diag_covhat_spline_pre))
View(cbind(scb_pre, scb_pre2))
B <- 300
T_boot <- numeric(B)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
betahat_spline_pre_b <- spline(betahat_pre_b, n=len_spline_pre, method="natural")$y
t_b <- (betahat_spline_pre_b - betahat_spline_pre)[-len_spline_pre] / sqrt(diag_covhat_spline_pre)[-len_spline_pre]
T_boot[b] <- min(abs(t_b))
}
quantile(T_boot, probs=1-scb.pre.alpha, type=8)
B <- 300
T_boot <- numeric(B)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
betahat_spline_pre_b <- spline(betahat_pre_b, n=len_spline_pre, method="natural")$y
t_b <- (betahat_spline_pre_b - betahat_spline_pre)[-len_spline_pre] / sqrt(diag_covhat_spline_pre)[-len_spline_pre]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
B <- 300
T_boot <- numeric(B)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
t_b <- (betahat_pre_b - betahat_pre)[-length(betahat_pre)] / sqrt(diag(covhat_pre))[-length(betahat_pre)]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
B <- 1000
T_boot <- numeric(B)
T_boot
B <- 1000
T_boot <- numeric(B)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
betahat_spline_pre_b <- spline(betahat_pre_b, n=len_spline_pre, method="natural")$y
t_b <- (betahat_spline_pre_b - betahat_spline_pre)[-len_spline_pre] / sqrt(diag_covhat_spline_pre)[-len_spline_pre]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
B <- 1000
T_boot <- numeric(B)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
t_b <- (betahat_pre_b - betahat_pre)[-length(betahat_pre)] / sqrt(diag(covhat_pre))[-length(betahat_pre)]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
B <- 300
T_boot <- numeric(B)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
betahat_spline_pre_b <- spline(betahat_pre_b, n=len_spline_pre, method="natural")$y
t_b <- (betahat_spline_pre_b - betahat_spline_pre)[-len_spline_pre] / sqrt(diag_covhat_spline_pre)[-len_spline_pre]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
B <- 300
T_boot <- numeric(B)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
t_b <- (betahat_pre_b - betahat_pre)[-length(betahat_pre)] / sqrt(diag(covhat_pre))[-length(betahat_pre)]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
B <- 500
T_boot <- numeric(B)
set.seed(100)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
betahat_spline_pre_b <- spline(betahat_pre_b, n=len_spline_pre, method="natural")$y
t_b <- (betahat_spline_pre_b - betahat_spline_pre)[-len_spline_pre] / sqrt(diag_covhat_spline_pre)[-len_spline_pre]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
B <- 500
T_boot <- numeric(B)
set.seed(100)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
t_b <- (betahat_pre_b - betahat_pre)[-length(betahat_pre)] / sqrt(diag(covhat_pre))[-length(betahat_pre)]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
B <- 500
T_boot <- numeric(B)
set.seed(850)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
betahat_spline_pre_b <- spline(betahat_pre_b, n=len_spline_pre, method="natural")$y
t_b <- (betahat_spline_pre_b - betahat_spline_pre)[-len_spline_pre] / sqrt(diag_covhat_spline_pre)[-len_spline_pre]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
B <- 500
T_boot <- numeric(B)
set.seed(850)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
t_b <- (betahat_pre_b - betahat_pre)[-length(betahat_pre)] / sqrt(diag(covhat_pre))[-length(betahat_pre)]
T_boot[b] <- min(abs(t_b))
}
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=8)
c_alpha
c_alpha <- quantile(T_boot, probs=1-scb.pre.alpha, type=4)
c_alpha
quantile(T_boot, probs=1-scb.pre.alpha, type=7)
quantile(T_boot, probs=1-scb.pre.alpha, type=6)
quantile(T_boot, probs=1-scb.pre.alpha, type=9)
B <- 500
T_boot <- numeric(B)
set.seed(450)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
betahat_spline_pre_b <- spline(betahat_pre_b, n=len_spline_pre, method="natural")$y
t_b <- (betahat_spline_pre_b - betahat_spline_pre)[-len_spline_pre] / sqrt(diag_covhat_spline_pre)[-len_spline_pre]
T_boot[b] <- min(abs(t_b))
}
quantile(T_boot, probs=1-scb.pre.alpha, type=6)
B <- 500
T_boot <- numeric(B)
set.seed(450)
for (b in 1:B) {
betahat_pre_b <- MASS::mvrnorm(1, mu=betahat_pre, Sigma=covhat_pre)
t_b <- (betahat_pre_b - betahat_pre)[-length(betahat_pre)] / sqrt(diag(covhat_pre))[-length(betahat_pre)]
T_boot[b] <- min(abs(t_b))
}
quantile(T_boot, probs=1-scb.pre.alpha, type=6)
