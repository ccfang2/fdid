p    <- 21 # number of time points
N    <- 200
grid <- round(ffscb::make_grid(p, rangevals = c(-10,10)),6)
## Covariance
cov  <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid, cov.f.params = c(1/2,1))
epsilon  <- make_sample(mean.v = rep(0, p), cov.m = cov,  N = N, dist = "rnorm")
## Temporal fixed effect
phi_t <- meanf_shift((grid+10)/20, 0)*2.5 # plot(y = phi_t, x = grid, type="l")
## Average treatment effect
beta_fct1  <- function(x) ifelse(x + 5 <= 0, 0, 3*(x+5)^2/(3+(x+5)^2) )
beta_t1    <- beta_fct1(grid)
beta_fct2  <- function(x) ifelse(x<=0, 0, 3*x^2/(3+x^2) )
beta_t2    <- beta_fct2(grid)
beta_fct3  <- function(x) ifelse(x - 5 <= 0, 0, 3*(x-5)^2/(3+(x-5)^2) )
beta_t3    <- beta_fct3(grid)
## Individual fixed effect
lambda_i <- runif(N, -3, 3)
## Treatment Assignment
pi  <- as.vector(exp(3*lambda_i)/(1+exp(3*lambda_i)))
D_i <- sapply(pi, function(x) rbinom(n=1,size=1,prob=x))
t0  <- ifelse(D_i == 1, sample(c(-5, 0, 5), sum(D_i == 1), replace = TRUE), NA)
## Covariates
# covar1 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
# covar2 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
covar_1 <- rnorm(N, 0, sd=1)
xi_1 <- meanf_shift((grid+7)/20, -2)*2
covar_2 <- runif(N,-3,3)
xi_2 <- meanf_shift((grid+15)/20, 3)*1.5
## Responses
Y <- sapply(1:N, function(x) dplyr::case_when( t0[x]==-5  ~ beta_t1 + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
t0[x]==0   ~ beta_t2 + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
t0[x]==5   ~ beta_t3 + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
is.na(t0[x]) ~         lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x]))
## Output
data <- data.frame(y1=as.vector(Y),t=rep(grid, times=N), i=rep(1:N, each=p))
treatment <- data.frame(i1=1:N, t01=t0, x11=covar_1, x2=covar_2)
fdid <- function(data,
treatment)
{
options(warn=-1)
# rename columns of data frames
colnames(data) <- c("y", "t", "i")
colnames(treatment)[1:2] <- c("i","t0")
#check conditions
if(!is.numeric(data$t)) stop("The time index should be numeric.")
if(!is.numeric(data$y)) stop("The outcome variable should be numeric.")
if(!all(na.omit(unique(treatment$t0)) %in% unique(data$t))) stop("The reference time in the data frame 'treatment' should be among the time index in the data frame 'data'.")
if(!all(na.omit(unique(treatment$t0)) > min(unique(data$t)) & na.omit(unique(treatment$t0)) < max(unique(data$t)))) stop("The reference time in the data frame 'treatment' should be greater/less than the min/max of time index in the data frame 'data'.")
if(!(NA %in% unique(treatment$t0))) stop("There must be control units with t0=NA as defined in the data frame 'treatment'.")
# join the two data frames
data                <- data[order(data$i, data$t), ]
treatment           <- treatment[order(treatment$i), ]
treatment[,-(1:2)] <- apply( treatment[,-(1:2)], 2, function(x) x-mean(x))
data                <- dplyr::left_join(data, treatment, by="i") # we need to left join them so that we can have a data list with the name of t0
data_list           <- split(data, ifelse(is.na(data$t0), "NA", data$t0))
# define a function for estimating beta and cov by each t0
fdid_nonstagger <- function(t0) {
## apply two way transformation on the data frame 'data'
data_nonstagger        <- rbind(data_list[[as.character(t0)]], data_list[["NA"]])
data_nonstagger        <- subset(data_nonstagger, select = -c(t0))
#var_names              <- setdiff(colnames(data_nonstagger), c("t","i"))
t_i_sorted             <- cbind(data_nonstagger$t, data_nonstagger$i)[order(data_nonstagger$i, data_nonstagger$t),]
t_sorted               <- t_i_sorted[,1]
i_sorted               <- t_i_sorted[,2]
#data_nonstagger_transf <- data_nonstagger %>% dplyr::mutate(across(all_of(var_names), ~tw_transf(.x,t,i)$x)) %>% dplyr::select(all_of(var_names)) %>% dplyr::mutate(t=t_sorted, i=i_sorted)
data_nonstagger_transf <- data_nonstagger %>% dplyr::mutate(across(y, ~tw_transf(.x,t,i)$x)) %>% dplyr::select(y) %>% dplyr::mutate(t=t_sorted, i=i_sorted)
## pre-process the data frame 'treatment'
treatment_nonstagger          <- treatment[treatment$t0==t0 | is.na(treatment$t0),]
treatment_nonstagger$d        <- ifelse(is.na(treatment_nonstagger$t0), 0, 1)
treatment_nonstagger$d_transf <- treatment_nonstagger$d-mean(treatment_nonstagger$d)
treatment_nonstagger_transf   <- subset(treatment_nonstagger, select=-c(t0,d))
treatment_nonstagger_transf   <- treatment_nonstagger_transf[order(match(treatment_nonstagger_transf[,"i"], unique(data_nonstagger_transf$i))),]
## join the transformed 'data' and pre-processed 'treatment'
data_nonstagger_transf <- dplyr::left_join(data_nonstagger_transf, treatment_nonstagger_transf, by="i")
t_unique               <- unique(data_nonstagger_transf$t)
## estimate beta
est_list        <- lapply(t_unique, function(x) solve(crossprod(as.matrix(subset(data_nonstagger_transf[data_nonstagger_transf$t==x,], select=-c(y,t,i)))), crossprod(as.matrix(subset(data_nonstagger_transf[data_nonstagger_transf$t==x,], select=-c(y,t,i))), as.vector(subset(data_nonstagger_transf[data_nonstagger_transf$t==x,], select=y))$y)))
names(est_list) <- t_unique
K               <- ncol(data_nonstagger_transf)-3
gamma           <- cbind(gamma = sapply(est_list, function(x) x[K]), t = t_unique)
rownames(gamma) <- NULL
gamma0          <- gamma[gamma[,"t"]==t0, -2]
beta            <- cbind(beta = gamma[,"gamma"]-gamma0, t = t_unique)
## estimate xi_tilde
if (K != 1){
xi_tilde           <- cbind(t(sapply(est_list, function(x) x[-K])), t_unique)
rownames(xi_tilde) <- NULL
colnames(xi_tilde) <- c(var_names[-1], "t")
}
## estimate covariance of beta
y_transf_fitted        <- lapply(t_unique, function(x) as.matrix(subset(data_nonstagger_transf[data_nonstagger_transf$t==x,], select=-c(y,t,i))) %*% est_list[[as.character(x)]])
names(y_transf_fitted) <- t_unique
resid_transf           <- lapply(t_unique, function(x) y_transf_fitted[[as.character(x)]]-as.vector(subset(data_nonstagger_transf[data_nonstagger_transf$t==x,], select=y))$y)
names(resid_transf)    <- t_unique
N_nonstagger     <- length(unique(data_nonstagger_transf$i))
cov_gamma        <- matrix(unlist(lapply(t_unique, function(x) lapply(t_unique, function(y) solve(1/N_nonstagger*crossprod(treatment_nonstagger_transf$d_transf)) %*% (1/(N_nonstagger-K)* t(treatment_nonstagger_transf$d_transf) %*% diag(x = as.vector(resid_transf[[as.character(x)]])*as.vector(resid_transf[[as.character(y)]]), nrow = N_nonstagger) %*% treatment_nonstagger_transf$d_transf) %*% solve(1/N_nonstagger*crossprod(treatment_nonstagger_transf$d_transf)))))/N_nonstagger, ncol=length(t_unique))
cov_gamma_gamma0 <- cov_gamma[,which(t_unique==t0)]
se_gamma0        <- sqrt(cov_gamma[which(t_unique==t0), which(t_unique==t0)])
cov_beta                       <- (sweep(cov_gamma*N_nonstagger-cov_gamma_gamma0*N_nonstagger, 2, cov_gamma_gamma0*N_nonstagger, FUN="-") + se_gamma0^2*N_nonstagger)/N_nonstagger
cov_beta[which(t_unique==t0),] <- 0; cov_beta[,which(t_unique==t0)] <- 0
rownames(cov_beta)             <- colnames(cov_beta) <- t_unique
## standard error of xi_tilde
if (K != 1) {
est_var_list          <- lapply(t_unique, function(x) (solve(1/N_nonstagger*crossprod(as.matrix(subset(data_nonstagger_transf[data_nonstagger_transf$t==x,], select=-c(y,t,i))))) %*% (1/(N_nonstagger-K)*t(as.matrix(subset(data_nonstagger_transf[data_nonstagger_transf$t==x,], select=-c(y,t,i)))) %*% diag(as.vector(resid_transf[[as.character(x)]]^2), nrow = N_nonstagger) %*% as.matrix(subset(data_nonstagger_transf[data_nonstagger_transf$t==x,], select=-c(y,t,i)))) %*% solve(1/N_nonstagger*crossprod(as.matrix(subset(data_nonstagger_transf[data_nonstagger_transf$t==x,], select=-c(y,t,i))))))/N_nonstagger)
se_xi_tilde           <- cbind(t(sapply(est_var_list, function(x) sqrt(diag(x)[-K]))), t_unique)
colnames(se_xi_tilde) <- c(var_names[-1], "t")
}
## return output
output <- if (K != 1){
list(beta = list(coef = beta, cov = cov_beta),
xi_tilde   = list(coef = xi_tilde,   se  = se_xi_tilde))
} else {
list(beta = list(coef = beta, cov = cov_beta))
}
}
# run the function above for each t0
t0_unique                   <- na.omit(unique(treatment$t0))
fdid_nonstagger_list        <- lapply(t0_unique, fdid_nonstagger)
names(fdid_nonstagger_list) <- t0_unique
if (length(t0_unique)==1) {
# extract the output directly in non-staggered design with only one t0
fdid_nonstagger_list[[1]]$beta$coef[,"t"]     <- round(fdid_nonstagger_list[[1]]$beta$coef[,"t"]-t0_unique[1], 6)
colnames(fdid_nonstagger_list[[1]]$beta$coef) <- c("beta", "event_t")
final_output                                  <- append(fdid_nonstagger_list[[1]], list(t0=0, df=NULL))
} else {
# estimate beta in staggered design with multiple t0
beta_list      <- lapply(1:length(t0_unique), function(x) cbind(beta=fdid_nonstagger_list[[x]]$beta$coef[,"beta"], event_t= round(fdid_nonstagger_list[[x]]$beta$coef[,"t"]-t0_unique[x], 6)))
t_unique       <- unique(data_list[["NA"]][["t"]])
event_t_list   <- sapply(beta_list, function(x) x[,"event_t"])
event_t_unique <- sort(unique(as.vector(event_t_list)))
N_t0           <- sapply(t0_unique, function(x) sum(treatment$t0==x, na.rm=TRUE) )
beta_stagger_list <- lapply(beta_list, function(x) cbind(beta = NA, event_t = event_t_unique))
beta_stagger_list <- Map(function( beta_stagger_mat,beta_mat) {
match_idx <- match(beta_mat[, "event_t"], beta_stagger_mat[, "event_t"])  # find matching indices
valid_idx <- !is.na(match_idx)  # remove NA matches
beta_stagger_mat[match_idx[valid_idx], "beta"] <- beta_mat[valid_idx, "beta"]
return(beta_stagger_mat)
}, beta_stagger_list, beta_list)
beta_stagger <- sapply(beta_stagger_list, function(x) x[,"beta"])
weights      <- t(apply(t(t(apply(event_t_list,2, function(x) event_t_unique%in%x ))*N_t0),1, function(y) y/sum(y)))
beta_stagger <- cbind(beta = rowSums(beta_stagger * weights, na.rm=TRUE), event_t=event_t_unique)
# estimate covariance of beta in staggered design
cov_beta_list <- lapply(fdid_nonstagger_list, function(x) x$beta$cov)
cov_beta_list <- lapply(1:length(cov_beta_list), function(x) {
rownames(cov_beta_list[[x]]) <- colnames(cov_beta_list[[x]]) <- event_t_list[,x]
return(cov_beta_list[[x]])
})
cov_beta_stagger_list <- lapply(cov_beta_list, function(x) matrix(NA, nrow=length(event_t_unique), ncol=length(event_t_unique), dimnames = list(event_t_unique,event_t_unique)))
replace_matrix_values <- function(A, B) {
common_rows <- intersect(rownames(A), rownames(B))  # find common row names
common_cols <- intersect(colnames(A), colnames(B))  # find common column names
A[common_rows, common_cols] <- B[common_rows, common_cols]  # replace matching values
return(A)
}
cov_beta_stagger_list <- Map(replace_matrix_values, cov_beta_stagger_list, cov_beta_list)
weights_mat_list <- lapply(1:ncol(weights), function(x) weights[,x] %o% weights[,x])
cov_beta_stagger <- Reduce(`+`, Map(function(mat1, mat2) mat1 * mat2,
lapply(cov_beta_stagger_list, function(x) replace(x, is.na(x), 0)),
lapply(weights_mat_list, function(x) replace(x, is.na(x), 0))))
na_indicator     <- Reduce(`&`, lapply(cov_beta_stagger_list, is.na))
na_indicator     <- ifelse(na_indicator, NA, 1)
cov_beta_stagger <- cov_beta_stagger*na_indicator
# collect all estimates of xi_tilde and its standard errors
if(length(fdid_nonstagger_list[[1]])!=1) {xi_tilde_list <- lapply(fdid_nonstagger_list, function(x) x$xi_tilde)}
# final output
final_output <- if(length(fdid_nonstagger_list[[1]])!=1) {
list(beta=list(coef= beta_stagger, cov=cov_beta_stagger),
xi_tilde=xi_tilde_list,
t0=0,
df=NULL)
} else {
list(beta=list(coef= beta_stagger, cov=cov_beta_stagger),
t0=0,
df=NULL)
}
}
class(final_output) <- "fdid"
return(final_output)
options(warn=1)
}
fdid_est <-fdid(data, treatment)
View(fdid_est)
plot(fdid_est$beta$coef[,2], fdid_est$beta$coef[,1], type="l")
View(fdid_est[["beta"]][["cov"]])
View(fdid_est)
fdid_est[["xi_tilde"]][["-5"]][["coef"]]
plot(fdid_est[["xi_tilde"]][["-5"]][["coef"]][,1])
plot(fdid_est[["xi_tilde"]][["-5"]][["coef"]][,2])
############
## Non-staggered
############
set.seed(200)
p    <- 41 # number of time points
N    <- 200
grid <- round(ffscb::make_grid(p, rangevals = c(-10,10)),6)
## Covariance
cov  <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid, cov.f.params = c(1/2,1))
epsilon  <- make_sample(mean.v = rep(0, p), cov.m = cov,  N = N, dist = "rnorm")
## Temporal fixed effect
phi_t <- meanf_shift((grid+10)/20, 0)*2.5
## Average treatment effect
beta_fct  <- function(x) ifelse(x<=0, 0, 3*x^2/(3+x^2))
beta_t    <- beta_fct(grid)
## Individual fixed effect
lambda_i <- runif(N, -3, 3)
## Treatment Assignment
pi  <- as.vector(exp(3*lambda_i)/(1+exp(3*lambda_i)))
D_i <- sapply(pi, function(x) rbinom(n=1,size=1,prob=x))
t0  <- ifelse(D_i == 1, 0, NA)
## Covariates
# covar1 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
# covar2 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
covar_1 <- rnorm(N, 0, sd=1)
xi_1 <- meanf_shift((grid+7)/20, -2)*2
covar_2 <- runif(N,-3,3)
xi_2 <- meanf_shift((grid+15)/20, 3)*1.5
## Responses
Y <- sapply(1:N, function(x) dplyr::case_when(t0[x]==0     ~ beta_t + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
is.na(t0[x]) ~          lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x]))
## Output
data <- data.frame(y1=as.vector(Y),t=rep(grid, times=N), i=rep(1:N, each=p))
treatment <- data.frame(i1=1:N, t01=t0, x11=covar_1, x2=covar_2)
fdid_est2<-fdid(data,treatment)
View(fdid_est2)
plot(fdid_est2[["beta"]][["coef"]][,2], fdid_est2[["beta"]][["coef"]][,1])
fdid_est2[["xi_tilde"]][["coef"]]
plot(fdid_est2[["xi_tilde"]][["coef"]][,1])
View(fdid_est)
set.seed(123)
p    <- 21 # number of time points
N    <- 200
grid <- round(ffscb::make_grid(p, rangevals = c(-10,10)),6)
## Covariance
cov  <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid, cov.f.params = c(1/2,1))
epsilon  <- make_sample(mean.v = rep(0, p), cov.m = cov,  N = N, dist = "rnorm")
## Temporal fixed effect
phi_t <- meanf_shift((grid+10)/20, 0)*2.5 # plot(y = phi_t, x = grid, type="l")
## Average treatment effect
beta_fct1  <- function(x) ifelse(x + 5 <= 0, 0, 3*(x+5)^2/(3+(x+5)^2) )
beta_t1    <- beta_fct1(grid)
beta_fct2  <- function(x) ifelse(x<=0, 0, 3*x^2/(3+x^2) )
beta_t2    <- beta_fct2(grid)
beta_fct3  <- function(x) ifelse(x - 5 <= 0, 0, 3*(x-5)^2/(3+(x-5)^2) )
beta_t3    <- beta_fct3(grid)
## Individual fixed effect
lambda_i <- runif(N, -3, 3)
## Treatment Assignment
pi  <- as.vector(exp(3*lambda_i)/(1+exp(3*lambda_i)))
D_i <- sapply(pi, function(x) rbinom(n=1,size=1,prob=x))
t0  <- ifelse(D_i == 1, sample(c(-5, 0, 5), sum(D_i == 1), replace = TRUE), NA)
## Covariates
# covar1 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
# covar2 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
covar_1 <- rnorm(N, 0, sd=1)
xi_1 <- meanf_shift((grid+7)/20, -2)*2
covar_2 <- runif(N,-3,3)
xi_2 <- meanf_shift((grid+15)/20, 3)*1.5
## Responses
Y <- sapply(1:N, function(x) dplyr::case_when( t0[x]==-5  ~ beta_t1 + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
t0[x]==0   ~ beta_t2 + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
t0[x]==5   ~ beta_t3 + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
is.na(t0[x]) ~         lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x]))
## Output
data <- data.frame(y=as.vector(Y), t=rep(grid, times=N), i=rep(1:N, each=p))
treatment <- data.frame(i=1:N, t0=t0, x1=covar_1, x2=covar_2)
getwd()
############
## Staggered
############
set.seed(123)
p    <- 21 # number of time points
N    <- 200
grid <- round(ffscb::make_grid(p, rangevals = c(-10,10)),6)
## Covariance
cov  <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid, cov.f.params = c(1/2,1))
epsilon  <- make_sample(mean.v = rep(0, p), cov.m = cov,  N = N, dist = "rnorm")
## Temporal fixed effect
phi_t <- meanf_shift((grid+10)/20, 0)*2.5 # plot(y = phi_t, x = grid, type="l")
## Average treatment effect
beta_fct1  <- function(x) ifelse(x + 5 <= 0, 0, 3*(x+5)^2/(3+(x+5)^2) )
beta_t1    <- beta_fct1(grid)
beta_fct2  <- function(x) ifelse(x<=0, 0, 3*x^2/(3+x^2) )
beta_t2    <- beta_fct2(grid)
beta_fct3  <- function(x) ifelse(x - 5 <= 0, 0, 3*(x-5)^2/(3+(x-5)^2) )
beta_t3    <- beta_fct3(grid)
## Individual fixed effect
lambda_i <- runif(N, -3, 3)
## Treatment Assignment
pi  <- as.vector(exp(3*lambda_i)/(1+exp(3*lambda_i)))
D_i <- sapply(pi, function(x) rbinom(n=1,size=1,prob=x))
t0  <- ifelse(D_i == 1, sample(c(-5, 0, 5), sum(D_i == 1), replace = TRUE), NA)
## Covariates
# covar1 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
# covar2 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
covar_1 <- rnorm(N, 0, sd=1)
xi_1 <- meanf_shift((grid+7)/20, -2)*2
covar_2 <- runif(N,-3,3)
xi_2 <- meanf_shift((grid+15)/20, 3)*1.5
## Responses
Y <- sapply(1:N, function(x) dplyr::case_when( t0[x]==-5  ~ beta_t1 + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
t0[x]==0   ~ beta_t2 + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
t0[x]==5   ~ beta_t3 + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
is.na(t0[x]) ~         lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x]))
## Output
simulated_stagger_data <- data.frame(y=as.vector(Y), t=rep(grid, times=N), i=rep(1:N, each=p))
simulated_stagger_treatment <- data.frame(i=1:N, t0=t0, x1=covar_1, x2=covar_2)
############
## Non-staggered
############
set.seed(123)
p    <- 41 # number of time points
N    <- 200
grid <- round(ffscb::make_grid(p, rangevals = c(-10,10)),6)
## Covariance
cov  <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid, cov.f.params = c(1/2,1))
epsilon  <- make_sample(mean.v = rep(0, p), cov.m = cov,  N = N, dist = "rnorm")
## Temporal fixed effect
phi_t <- meanf_shift((grid+10)/20, 0)*2.5
## Average treatment effect
beta_fct  <- function(x) ifelse(x<=0, 0, 3*x^2/(3+x^2))
beta_t    <- beta_fct(grid)
## Individual fixed effect
lambda_i <- runif(N, -3, 3)
## Treatment Assignment
pi  <- as.vector(exp(3*lambda_i)/(1+exp(3*lambda_i)))
D_i <- sapply(pi, function(x) rbinom(n=1,size=1,prob=x))
t0  <- ifelse(D_i == 1, 0, NA)
## Covariates
# covar1 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
# covar2 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
covar_1 <- rnorm(N, 0, sd=1)
xi_1 <- meanf_shift((grid+7)/20, -2)*2
covar_2 <- runif(N,-3,3)
xi_2 <- meanf_shift((grid+15)/20, 3)*1.5
## Responses
Y <- sapply(1:N, function(x) dplyr::case_when(t0[x]==0     ~ beta_t + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
is.na(t0[x]) ~          lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x]))
## Output
simulated_nonstagger_data <- data.frame(y1=as.vector(Y),t=rep(grid, times=N), i=rep(1:N, each=p))
simulated_nonstagger_treatment <- data.frame(i1=1:N, t01=t0, x11=covar_1, x2=covar_2)
save(simulated_stagger_data, simulated_stagger_treatment , file="simulated_stagger_example.rda")
save(simulated_nonstagger_data, simulated_nonstagger_treatment , file="simulated_nonstagger_example.rda")
getwd()
############
set.seed(123)
p    <- 41 # number of time points
N    <- 200
grid <- round(ffscb::make_grid(p, rangevals = c(-10,10)),6)
## Covariance
cov  <- ffscb::make_cov_m(cov.f = covf_st_matern, grid = grid, cov.f.params = c(1/2,1))
epsilon  <- make_sample(mean.v = rep(0, p), cov.m = cov,  N = N, dist = "rnorm")
## Temporal fixed effect
phi_t <- meanf_shift((grid+10)/20, 0)*2.5
## Average treatment effect
beta_fct  <- function(x) ifelse(x<=0, 0, 3*x^2/(3+x^2))
beta_t    <- beta_fct(grid)
## Individual fixed effect
lambda_i <- runif(N, -3, 3)
## Treatment Assignment
pi  <- as.vector(exp(3*lambda_i)/(1+exp(3*lambda_i)))
D_i <- sapply(pi, function(x) rbinom(n=1,size=1,prob=x))
t0  <- ifelse(D_i == 1, 0, NA)
## Covariates
# covar1 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
# covar2 <- t(sapply(grid^2, function(mu) rnorm(N, mu, sd=1)))
covar_1 <- rnorm(N, 0, sd=1)
xi_1 <- meanf_shift((grid+7)/20, -2)*2
covar_2 <- runif(N,-3,3)
xi_2 <- meanf_shift((grid+15)/20, 3)*1.5
## Responses
Y <- sapply(1:N, function(x) dplyr::case_when(t0[x]==0     ~ beta_t + lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x],
is.na(t0[x]) ~          lambda_i[x] + xi_1*covar_1[x] + xi_2*covar_2[x] + phi_t + epsilon[,x]))
## Output
simulated_nonstagger_data <- data.frame(y1=as.vector(Y),t=rep(grid, times=N), i=rep(1:N, each=p))
simulated_nonstagger_treatment <- data.frame(i1=1:N, t01=t0, x1=covar_1, x2=covar_2)
save(simulated_nonstagger_data, simulated_nonstagger_treatment , file="simulated_nonstagger_example.rda")
library(fdid)
data(LWdata)
fdid_scb_est <- fdid_scb(beta=LWdata$beta, cov=LWdata$cov, t0=LWdata$t0)
object<- fdid_scb_est
ta.t0=NULL
ta.s=NULL
frm.mbar=NULL
ftr.m=NULL
frmtr.mbar=NULL
post.trt=FALSE
ci=TRUE
pos.legend="top"
scale.legend=1
# check conditions
if (!base::inherits(object,"fdid_scb")) stop("The input 'object' should be an output of function 'fdid_scb'.")
if (!is.null(ta.t0) && (!is.numeric(ta.t0) || length(ta.t0) != 1)) stop("The input 'ta.t0' should be either NULL or a numeric scalar.")
if (!is.null(ta.t0) && !(ta.t0 %in% object$scb$event_t[which(object$scb$event_t<=object$data$t0)])) stop("If not NULL, the input 'ta.t0' should be among the pre-treatment event time in 'object'.")
if (!is.null(ta.t0) && ta.t0 == object$scb$event_t[1] && !all(sapply(list(frm.mbar, ftr.m, frmtr.mbar), is.null))) stop("If 'ta.t0' is defined to be the first event time, 'frm.mbar', 'ftr.m' and 'frmtr.mbar' must be NULL, because there is no available data for computing pre-trend differences.")
if (!is.null(ta.s) && (!is.numeric(ta.s) || length(ta.s) != 1 || ta.s < 0)) stop("The input 'ta.s' should be either NULL or a numeric non-negative scalar.")
if (!is.null(frm.mbar) && (!is.numeric(frm.mbar) || length(frm.mbar) != 1 || frm.mbar < 0)) stop("The input 'frm.mbar' should be either NULL or a numeric non-negative scalar.")
if (!is.null(ftr.m) && (!is.numeric(ftr.m) || length(ftr.m) != 1 || ftr.m < 0)) stop("The input 'ftr.m' should be either NULL or a numeric non-negative scalar.")
if (!is.null(frmtr.mbar) && (!is.numeric(frmtr.mbar) || length(frmtr.mbar) != 1 || frmtr.mbar < 0)) stop("The input 'frmtr.mbar' should be either NULL or a numeric non-negative scalar.")
if (!is.null(frm.mbar) && !is.null(ftr.m) && !is.null(frmtr.mbar)) stop("Exactly one of inputs 'frm.mbar', 'ftr.m' and 'frmtr.mbar' can have a value, or all three are NULL.")
if (!is.logical(post.trt)) stop("The input 'post.trt' should be logical.")
if (!is.logical(ci)) stop("The input 'ci' should be logical.")
if (!is.null(pos.legend) && !pos.legend %in% c("top", "bottom")) stop("The input 'pos.legend' must be 'top', 'bottom', or NULL.")
if (!is.numeric(scale.legend) || length(scale.legend) != 1 || scale.legend <= 0 || !is.finite(scale.legend)) stop("The input 'scale.legend' must be a positive number.")
# extract data from object
betahat <- object$data$beta[,1]
covhat  <- object$data$cov
timeVec <- object$data$beta[,2]
betahat_splinefun <- object$scb$betahat
scb_ub_splinefun  <- object$scb$scb_ub
scb_lb_splinefun  <- object$scb$scb_lb
ci_upper <- object$ci[,"ci_upper"]
ci_lower <- object$ci[,"ci_lower"]
start                     <- min(object$data$beta[,2])
end                       <- max(object$data$beta[,2])
t0                        <- object$data$t0
if (is.null(ta.t0)) ta.t0 <- t0
ta.t0
ta.t0=-3
if (is.null(ta.t0)) ta.t0 <- t0
ta.t0
ta.t0==t0 & is.null(frm.mbar) & is.null(ftr.m) & is.null(frmtr.mbar)
is.null(frm.mbar) & is.null(ftr.m) & is.null(frmtr.mbar)
if(is.null(ta.s)) {
ta_ub <- ci_upper[names(ci_upper)==as.character(ta.t0)]
ta_lb <- ci_lower[names(ci_lower)==as.character(ta.t0)]
} else {
ta_ub <- betahat[which(timeVec==ta.t0)]+ta.s*sqrt(diag(covhat)[which(timeVec==ta.t0)])
ta_lb <- betahat[which(timeVec==ta.t0)]-ta.s*sqrt(diag(covhat)[which(timeVec==ta.t0)])
}
honest_ub_splinefun <- function(x) ta_ub
honest_lb_splinefun <- function(x) ta_lb
honest_ub_splinefun <- Vectorize(honest_ub_splinefun)
honest_lb_splinefun <- Vectorize(honest_lb_splinefun)
!is.null(frm.mbar) & is.null(ftr.m) & is.null(frmtr.mbar)
is.null(frm.mbar) & is.null(ftr.m) & !is.null(frmtr.mbar)
# find the time spans of statistical significance
n.int <-200
roots_UB <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun         <- function(x) (scb_ub_splinefun(x)-honest_ub_splinefun(x))*(scb_lb_splinefun(x)-honest_ub_splinefun(x))
interval    <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root        <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots_UB[i] <- if(inherits(root, "try-error")) {NA} else root
}
roots_UB <- sort(unique(roots_UB[!is.na(roots_UB)]))
roots_LB <- vector("numeric", length = n.int)
for (i in 1:n.int) {
fun         <- function(x) (scb_ub_splinefun(x)-honest_lb_splinefun(x))*(scb_lb_splinefun(x)-honest_lb_splinefun(x))
interval    <- c(start+(i-1)*(end-start)/n.int, start+(i)*(end-start)/n.int)
root        <- try(uniroot(fun, interval = interval)$root, silent = TRUE)
roots_LB[i] <- if(inherits(root, "try-error")) {NA} else root
}
roots_LB <-  sort(unique(roots_LB[!is.na(roots_LB)]))
roots_UB_vec <- sort(unique(c(start,roots_UB,end)))
roots_LB_vec <- sort(unique(c(start,roots_LB,end)))
roots_vec    <- sort(unique(c(start,end,roots_UB, roots_LB)))
stat_sig_UB_vec <- rep(NA, length(roots_UB_vec)-1)
stat_sig_LB_vec <- rep(NA, length(roots_LB_vec)-1)
for (i in 1:(length(roots_UB_vec)-1)) {
test_point <- (roots_UB_vec[i]+roots_UB_vec[i+1])/2
scb_ub_sign <- sign(scb_ub_splinefun( test_point)-honest_ub_splinefun(test_point))
scb_lb_sign <- sign(scb_lb_splinefun( test_point)-honest_ub_splinefun(test_point))
stat_sig_UB_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
for (i in 1:(length(roots_LB_vec)-1)) {
test_point <- (roots_LB_vec[i]+roots_LB_vec[i+1])/2
scb_ub_sign <- sign(scb_ub_splinefun( test_point)-honest_lb_splinefun(test_point))
scb_lb_sign <- sign(scb_lb_splinefun( test_point)-honest_lb_splinefun(test_point))
stat_sig_LB_vec[i] <- (scb_ub_sign+scb_lb_sign)/2
}
interval_fun <- function(x, a, b) {
if (length(b) != length(a) - 1) {
stop("Vector 'b' must be one element shorter than vector 'a'.")
}
for (i in 1:(length(a) - 1)) {
if (x >= a[i] && x <= a[i + 1]) {
return(b[i])
}
}
return(NA)
}
fun_stat_sig_UB_vec <- function(x) interval_fun(x, roots_UB_vec, stat_sig_UB_vec)
fun_stat_sig_LB_vec <- function(x) interval_fun(x, roots_LB_vec, stat_sig_LB_vec)
fun_stat_sig_UB_vec <- Vectorize(fun_stat_sig_UB_vec)
fun_stat_sig_LB_vec <- Vectorize(fun_stat_sig_LB_vec)
fun_stat_sig_vec <- function(x) {if(fun_stat_sig_UB_vec(x) == fun_stat_sig_LB_vec(x)) fun_stat_sig_UB_vec(x) else 0}
fun_stat_sig_vec <- Vectorize(fun_stat_sig_vec)
x_vals  <- seq(start, end, length.out=5*length(timeVec))
y_range <- range(c(betahat_splinefun(x_vals), scb_ub_splinefun(x_vals), scb_lb_splinefun(x_vals)), na.rm=TRUE)
plot(timeVec, betahat,  type = "p", ylim =y_range, xlab = "Event Time", ylab = "", pch = 16, col = "blue", ...)
plot(timeVec, betahat,  type = "p", ylim =y_range, xlab = "Event Time", ylab = "", pch = 16, col = "blue")
grid()
if(isTRUE(ci)) arrows(timeVec, ci_lower, timeVec, ci_upper, angle = 90, code = 3, length = 0.025, col = "blue4")
curve(betahat_splinefun, add=TRUE, lty=1)
curve(scb_ub_splinefun, add=TRUE, lty=1)
curve(scb_lb_splinefun, add=TRUE, lty=1)
ShadeBetween <- function(x1, x2, f1, f2, ...) {polygon(c(x1, rev(x2)), c(f1, rev(f2)), ...)}
isTRUE(post.trt)
segments(x0=start, y0=0, x1=end, y1=0, lty=3, lwd=4, col="red")
ShadeBetween(timeVec, timeVec, honest_ub_splinefun(timeVec), honest_lb_splinefun(timeVec), col=rgb(1,0,0,alpha=0.3), border=NA)
for (i in 1:(length(roots_vec)-1) ) {
if ( fun_stat_sig_vec((roots_vec[i]+roots_vec[i+1])/2)==1  ) {
rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.7), border=NA)
} else {
if (fun_stat_sig_vec((roots_vec[i]+roots_vec[i+1])/2)==-1) {
rect(roots_vec[i], y_range[1], roots_vec[i+1], y_range[2], col=rgb(0.5, 0.5, 0.5, alpha=0.4), border=NA)
}
}
}
!is.null(pos.legend)
library(fdid)
library(fdid)
